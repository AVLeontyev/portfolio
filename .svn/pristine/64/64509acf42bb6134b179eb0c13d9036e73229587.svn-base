using System;
using System.IO;
using System.Data;
using System.Collections.Generic;
using System.Threading;
using System.Drawing; //Color
using System.Globalization; //...CultureInfo

//using HClassLibrary;
using StatisticCommon;
using ASUTP;
using ASUTP.Core;
using System.Linq;
using System.Threading.Tasks;
using StatisticCommon.Contract.Alarm;

namespace SAlarm.Service
{
    /// <summary>
    /// Класс объект для обращения к данным
    /// </summary>
    public class TecViewAlarm : StatisticCommon.TecView
    {
        /// <summary>
        /// Класс для описания аргумента при возникновении события - сигнализация
        /// </summary>
        public class AlarmTecViewEventArgs : AlarmNotifyEventArgs
        {
            /// <summary>
            /// Структура для описания элемента при детализации
            ///  случая выполнения условий сигнализаций
            /// </summary>
            public struct EventDetail
            {
                /// <summary>
                /// Идентификатор компонента, информация детализации события для которого размещается в объекте
                /// </summary>
                public int id;
                /// <summary>
                /// Значение, детализизурующее событие
                /// </summary>
                public value value;

                public int id_tm;

                public new string ToString()
                {
                    return value.ToString ();
                }
            }

            public int Id { get { return
                //m_id_tg < 0 ? m_id_gtp : m_id_tg
                m_id_comp
                ; } }

            public List<EventDetail> m_listEventDetail;

            public AlarmTecViewEventArgs(int id_comp, StatisticCommon.OICDAC.DbInterface.OIKParameter oicdac_param, EventReason r, DateTime dtReg, int s, List<EventDetail> listEventDetail)
                : base(id_comp, oicdac_param, r, dtReg, s)
            {
                m_listEventDetail = listEventDetail;
            }
        }
        /// <summary>
        /// Делегат - тип обработчика события 'EventReg'
        ///  регистрации случая выполнения условия сигнализаций
        /// </summary>
        /// <param name="ev">Аргумент при возникновении события</param>
        public delegate void AlarmTecViewEventHandler (AlarmTecViewEventArgs ev);
        /// <summary>
        /// Событие для регистрации случая выполнения условия сигнализаций
        ///  в режиме "выполнения_приложения"
        /// </summary>
        public event AlarmTecViewEventHandler EventReg;
        /// <summary>
        /// Правило, описывающее использование одного из типов сигнализации
        /// </summary>
        public class RULE
        {
            /// <summary>
            ///  Признак выполнения с интервалом, указанным в БД конфигурации
            ///   , иначе - с минимальным(ежесекундно) интервалом
            /// </summary>
            private bool _bStandardUpdate;

            public DateTime LastRun;

            public bool IsRunable
            {
                get
                {
                    return LastRun < DateTime.MaxValue;
                }
            }

            public bool IsRequired
            {
                get
                {
                    return (IsRunable == true) // разрешено выполнять проверку
                        && ((_bStandardUpdate == false) // ежесекундный(безусловный) интервал обновления
                            || ((_bStandardUpdate == true) // стандартный интервал обновления
                                && ((DateTime.Now - LastRun).TotalMilliseconds > AdminAlarm.MSEC_ALARM_TIMERUPDATE))); // проверить необходимость обновления по стандартному интервалу обновления
                }
            }

            private RULE (bool bStandardUpdate = true)
            {
                _bStandardUpdate = bStandardUpdate;
                LastRun = DateTime.MaxValue;
            }

            public RULE (bool bRunable, bool bStandardUpdate)
                : this(bStandardUpdate)
            {
                if (bRunable == true)
                    LastRun = DateTime.MinValue;
                else
                    ;
            }

            /// <summary>
            /// Обновить метку времени крайнего выполнения проверки правила
            /// </summary>
            public void Update ()
            {
                LastRun = DateTime.Now;
            }
        }

        private Dictionary<TYPE_ALARM, RULE> _dictRules;
        /// <summary>
        /// Конструктор - основной (параметры - базового класа)
        /// </summary>
        /// <param name="key">Ключ элемента</param>
        /// <param name="runable">Массив, определящий вкл./откл. типа сигнализации</param>
        public TecViewAlarm (FormChangeMode.KeyDevice key, TYPE_ALARM runable)
            : base(key, TECComponentBase.TYPE.ELECTRO)
        {
            bool bRunable = false;
            StatisticCommon.OICDAC.DbInterface.OIKParameter param;

            update_TGTurnOnOff = new IntDelegateFunc (AlarmRegistred);
            updateGUI_Fact = new IntDelegateIntIntFunc (AlarmRegistred);
            updateGUI_TM = new IntDelegateParamFunc (AlarmRegistred);

            _dictRules = new Dictionary<TYPE_ALARM, RULE> ();
            // все правила, кроме проверки по частоте, выполняются через стандартный интервал
            foreach (TYPE_ALARM run in Enum.GetValues (typeof (TYPE_ALARM))) {
                if (run == TYPE_ALARM.UNKNOWN)
                    continue;
                else
                    ;

                bRunable = runable.HasFlag (run) == true;
                _dictRules.Add (run, new RULE (bRunable, !(run == TYPE_ALARM.APOWER) || !(run == TYPE_ALARM.FREQ)));

                switch (run) {
                    case TYPE_ALARM.TG_TURNONOFF:
                    case TYPE_ALARM.APOWER:
                        param = StatisticCommon.OICDAC.DbInterface.OIKParameter.APOWER;
                        break;
                    case TYPE_ALARM.FREQ:
                        param = StatisticCommon.OICDAC.DbInterface.OIKParameter.FREQUENCY;
                        break;
                    case TYPE_ALARM.CUR_POWER:
                    default:
                    // 'LastValue' - не требуется
                        param = StatisticCommon.OICDAC.DbInterface.OIKParameter.UNKNOWN;
                        break;
                }

                if (!(param == StatisticCommon.OICDAC.DbInterface.OIKParameter.UNKNOWN))
                    if (m_dictLastValue_TM_Required[param] == false)
                    //!!! т.к. один 'param' на несколько типов сигнализации, то разрешение можно только установить, отменить - нельзя
                        m_dictLastValue_TM_Required[param] = bRunable;
                    else
                        ;
                else
                    ;
            }
            // создать 1-ый токен для завершения задачи по тайм-ауту
            createCancelTokenTaskChangeState ();
        }

        public bool IsRegistredRequired
        {
            get
            {
                return _dictRules.Values.Any (rule => {
                    return rule.IsRequired == true;
                });
            }
        }

        /// <summary>
        /// Возвратить признак необходимости регистрации событий для типа сигнализации
        /// </summary>
        /// <param name="type">Тип сигнализации</param>
        /// <returns>Признак необходимости регистрации событий</returns>
        public bool GetAlarmRegistredRequired (TYPE_ALARM type)
        {
            return (Equals (_dictRules, null) == false)
                && (_dictRules.ContainsKey (type) == true)
                && (_dictRules[type].IsRequired == true);
        }

        private bool _bChangeStateRunning;

        private CancellationToken _cancelTaskChangeState;

        private void createCancelTokenTaskChangeState ()
        {
            _cancelTaskChangeState = new CancellationTokenSource (TimeSpan.FromSeconds (AdminAlarm.MSEC_ALARM_MAX_UPDATE)).Token;
        }

        public override void ChangeState()
        {
            if ((_bChangeStateRunning == false)
                && (_dictRules.Count > 0)) {
                if (_cancelTaskChangeState.IsCancellationRequested == true)
                // предыдущий токен во вкл. состоянии; создать новый
                    createCancelTokenTaskChangeState ();
                else
                    ;

                Task.Factory.StartNew (() => {
                    try {
                        _bChangeStateRunning = true;

                        threadGetRDGValues (null);
                    } catch (OperationCanceledException eCancel) {
                        // попытаемся корректно завершить поток 'threadGetRDGValues'
                        SetSyncState (INDEX_WAITHANDLE_REASON.BREAK);
                    }
                }
                , _cancelTaskChangeState)
                .ContinueWith ((taskComleted) => {
                        _bChangeStateRunning = false;
                    });
            } else
                ;

            //base.ChangeState(); //Run
        }

        /// <summary>
        /// Поток запроса значений для 'TecViewAlarm'
        /// </summary>
        /// <param name="synch">Объект для синхронизации</param>
        private void threadGetRDGValues(object synch)
        {
            INDEX_WAITHANDLE_REASON indxEv = INDEX_WAITHANDLE_REASON.SUCCESS;

            //if (m_waitHandleState[(int)INDEX_WAITHANDLE_REASON.SUCCESS].WaitOne (0, true) == false)
                SetSyncState(INDEX_WAITHANDLE_REASON.SUCCESS);
            //else ;

            ResetSyncState ();

            foreach (TECComponent tc in allTECComponents)
            {
                if (tc.IsGTP == true)
                {
                    indxEv = WaitAny(ASUTP.Core.Constants.MAX_WATING, true);
                    if (indxEv == INDEX_WAITHANDLE_REASON.BREAK)
                        break;
                    else
                    {
                        if (!(indxEv == INDEX_WAITHANDLE_REASON.SUCCESS))
                            ResetSyncState ((INDEX_WAITHANDLE_REASON)indxEv);
                        else
                            ;

                        CurrentKey = new FormChangeMode.KeyDevice () { Id = tc.m_id, Mode = tc.Mode };

                        getRDGValues();
                    }
                }
                else
                    ; //Это не ГТП
            }
        }
        /// <summary>
        /// Запросить значения для 'TecViewAlarm'
        /// </summary>
        private void getRDGValues()
        {
            GetRDGValues(CurrentKey, DateTime.Now);

            Run(@"TecView::GetRDGValues () - ...");
        }
        /// <summary>
        /// Добавить состояния для запроса получения значений 'TecViewAlarm'
        /// </summary>
        /// <param name="key">Ключ компонента</param>
        /// <param name="date">Дата запрашиваемых значений</param>
        public override void GetRDGValues(FormChangeMode.KeyDevice key, DateTime date)
        {
            bool bTGTurnOnOffUpdateRequired = false;

            m_prevDate = m_curDate;
            m_curDate = date.Date;

            ClearStates();

            adminValuesReceived = false;

            if ((m_tec.GetReadySensorsStrings (_type) == false))
            {
                AddState((int)StatesMachine.InitSensors);
            }
            else ;

            if (currHour == true)
                AddState((int)StatesMachine.CurrentTimeView);
            else
                ;

            if (GetAlarmRegistredRequired(TYPE_ALARM.CUR_POWER) == true) {
                //??? а где AISKUE+SOTIASSO
                if (m_arTypeSourceData[(int)HDateTime.INTERVAL.HOURS] == CONN_SETT_TYPE.DATA_AISKUE)
                    AddState((int)StatesMachine.Hours_Fact);
                else
                    if ((m_arTypeSourceData[(int)HDateTime.INTERVAL.HOURS] == CONN_SETT_TYPE.DATA_SOTIASSO_3_MIN)
                        || (m_arTypeSourceData[(int)HDateTime.INTERVAL.HOURS] == CONN_SETT_TYPE.DATA_SOTIASSO_1_MIN)
                        || (m_arTypeSourceData[(int)HDateTime.INTERVAL.HOURS] == CONN_SETT_TYPE.DATA_SOTIASSO))
                        AddState((int)StatesMachine.Hours_TM);
                    else
                        ;

                if (m_arTypeSourceData[(int)HDateTime.INTERVAL.MINUTES] == CONN_SETT_TYPE.DATA_AISKUE)
                    AddState((int)StatesMachine.CurrentMins_Fact);
                else
                    if ((m_arTypeSourceData[(int)HDateTime.INTERVAL.MINUTES] == CONN_SETT_TYPE.DATA_SOTIASSO_3_MIN)
                        || (m_arTypeSourceData[(int)HDateTime.INTERVAL.MINUTES] == CONN_SETT_TYPE.DATA_SOTIASSO_1_MIN)
                        || (m_arTypeSourceData[(int)HDateTime.INTERVAL.MINUTES] == CONN_SETT_TYPE.DATA_SOTIASSO))
                        AddState((int)StatesMachine.CurrentMins_TM);
                    else
                        ;
            } else
                ;

            // для хотя бы одного типв сигнализации требуются текущие значения ТГ (ТГ вкл./выкл.)
            if (IsRegistredRequired == true) 
                AddState ((int)StatesMachine.LastValue_TM_Gen);
            else
                ;

            if (GetAlarmRegistredRequired (TYPE_ALARM.FREQ) == true) {
                if (m_dictLastValue_TM_Required[StatisticCommon.OICDAC.DbInterface.OIKParameter.FREQUENCY] == true)
                    AddState ((int)StatesMachine.LastValue_TM_Freq);
                else
                    ;
            } else
                ;

            if (GetAlarmRegistredRequired (TYPE_ALARM.CUR_POWER) == true) {
                AddState ((int)StatesMachine.PPBRValues);
                AddState ((int)StatesMachine.AdminValues);
            } else
                ;
        }

        /// <summary>
        /// Функция проверки выполнения условий ТГ вкл./выкл. сигнализаций (для одного ГТП)
        /// </summary>
        /// <returns>Признак выполнения функции</returns>
        public int AlarmRegistred()
        {
            //Признак выполнения функции
            int iRes = (int)ASUTP.Helper.HHandler.INDEX_WAITHANDLE_REASON.SUCCESS;
            //Признак состояния для сигнализации "ТГ вкл./откл." - исходный
            // дублирование для 'situation' в контексте типа сигнализации 'TG.INDEX_TURNOnOff'
            StatisticCommon.TG.INDEX_TURNOnOff curTurnOnOff = StatisticCommon.TG.INDEX_TURNOnOff.UNKNOWN;

            foreach (StatisticCommon.TG tg in allTECComponents.Find(comp => comp.m_id == CurrentKey.Id).ListLowPointDev) {
                curTurnOnOff = StatisticCommon.TG.INDEX_TURNOnOff.UNKNOWN;

                if (m_dictValuesLowPointDev[tg.m_id].m_valuesTM[StatisticCommon.OICDAC.DbInterface.OIKParameter.APOWER].Data < 1F)
                    //??? проверять ли значение на '< 0F'
                    if (!(m_dictValuesLowPointDev[tg.m_id].m_valuesTM[StatisticCommon.OICDAC.DbInterface.OIKParameter.APOWER].Data < 0F))
                        curTurnOnOff = StatisticCommon.TG.INDEX_TURNOnOff.OFF;
                    else
                        ; //??? неопределенное состояние ТГ
                else
                {//Больше ИЛИ равно 1F
                    //situation =
                    curTurnOnOff =
                        //(int)
                            StatisticCommon.TG.INDEX_TURNOnOff.ON
                        ;
                }

                if (! (curTurnOnOff == StatisticCommon.TG.INDEX_TURNOnOff.UNKNOWN)) {
                    tg.m_TurnOnOff = curTurnOnOff;
                    
                    if (tg.IsTurnOnOffNew == true)
                    {
                        if (GetAlarmRegistredRequired (TYPE_ALARM.TG_TURNONOFF) == true)
                            // регистрация события сигнализации: вкл./выкл. ТГ
                            EventReg?.Invoke (new TecViewAlarm.AlarmTecViewEventArgs (tg.m_id
                                , StatisticCommon.OICDAC.DbInterface.OIKParameter.UNKNOWN
                                , new AlarmNotifyEventArgs.EventReason () {
                                    value = m_dictValuesLowPointDev [tg.m_id].m_valuesTM [StatisticCommon.OICDAC.DbInterface.OIKParameter.APOWER].Data
                                    , UDGe = -1F
                                    , koeff = -1 //??? не используется
                                }
                                , DateTime.UtcNow
                                , (int)curTurnOnOff
                                , new List<AlarmTecViewEventArgs.EventDetail> () { }));
                        else
                            ;

                        //Прекращаем текущий цикл...
                        break;
                    }
                    else
                        ; //Состояние ТГ не изменилось
                } else
                    //Текущее состояние ТГ не удалось определить
                    Logging.Logg().Warning (@"TecViewAlarm::AlarmRegistred (id_tg=" + tg.m_id + @") - Detail: "
                        + m_dictValuesLowPointDev [tg.m_id].m_valuesTM [StatisticCommon.OICDAC.DbInterface.OIKParameter.APOWER].Data
                        , Logging.INDEX_MESSAGE.NOT_SET);
            }

            return iRes;
        }

        /// <summary>
        /// Функция проверки выполнения условий сигнализаций (для одного ГТП)
        /// </summary>
        /// <param name="curHour">Текущий час</param>
        /// <param name="curMinute">Текущий интервал (1-мин) - текущая минута указанного часа</param>
        /// <returns>Признак выполнения функции</returns>
        public int AlarmRegistred(int curHour, int curMinute)
        {
            //return EventAlarmDetect(m_tec.m_id, curHour, curMinute);

            //Признак выполнения функции
            int iRes = (int)ASUTP.Helper.HHandler.INDEX_WAITHANDLE_REASON.SUCCESS
                //, iDebug = -1 //-1 - нет отладки, 0 - раб./отладка, 1 - имитирование
                //, situation = -1 // ситуация для события
                , cntTGTurnOn = 0 // кол-во вкл. ТГ
                , cntTGTurnUnknown = -1 // кол-во ТГ с неизвестным состоянием
                , cntPower_TMValues = 0; //Счетчик кол-ва значений тек./мощн. ТГ в общем значении мощности для ГТП
            //Константы
            double power_TM = StatisticCommon.Constants.InvalidValue;
            List<TECComponentBase> listLowPointDev;
            //Список объектов, детализирующих событие сигнализации
            List<TecViewAlarm.AlarmTecViewEventArgs.EventDetail> listEventDetail = new List<TecViewAlarm.AlarmTecViewEventArgs.EventDetail>();

            //if (((lastHour == 24) || (lastHourError == true)) || ((lastMin == 0) || (lastMinError == true)))
            if (((curHour == 24) || (m_markWarning.IsMarked((int)INDEX_WARNING.LAST_HOUR) == true))
                || ((curMinute == 0) || (m_markWarning.IsMarked((int)INDEX_WARNING.LAST_MIN) == true)))
            {
                Logging.Logg().Error($@"TecView::AlarmEventRegistred (TEC={m_tec.name_shr}, [KeyComponent={CurrentKey}])"
                        + $@" - curHour={curHour}; curMinute={curMinute}"
                    , Logging.INDEX_MESSAGE.NOT_SET);
            }
            else
            {
                listLowPointDev = allTECComponents.Find (comp => comp.m_id == CurrentKey.Id).ListLowPointDev;
                cntTGTurnUnknown = listLowPointDev.Count;

                #region ТГ вкл./выкл.
                foreach (StatisticCommon.TG tg in listLowPointDev)
                {
                    if (tg.IsTurnOnOffNew == true) {
                        // признак для отмены выполнения проверки 'CUR_POWER'
                        power_TM = StatisticCommon.Constants.InvalidValue;
                        // прекратить выполнение один из ТГ только что вкл./выкл.
                        break;
                    } else {
                        if (tg.m_TurnOnOff == TG.INDEX_TURNOnOff.ON) {
                        //ТГ вкл.
                            // подготовить значение
                            if (IsValueValidate ((float)power_TM) == true) power_TM = 0F; else ;
                            // учесть в общем значении мощности ГТП, текущую мощность ТГ
                            power_TM += m_dictValuesLowPointDev[tg.m_id].m_valuesTM[StatisticCommon.OICDAC.DbInterface.OIKParameter.APOWER].Data;
                            // увеличить счетчик 
                            cntPower_TMValues ++;
                        } else
                            ;
                    
                        //??? неизвестный идентификатор источника значений СОТИАССО (id_tm = -1)
                        listEventDetail.Add(new TecViewAlarm.AlarmTecViewEventArgs.EventDetail()
                        {
                            id = tg.m_id
                            , value = m_dictValuesLowPointDev[tg.m_id].m_valuesTM[StatisticCommon.OICDAC.DbInterface.OIKParameter.APOWER]
                            , id_tm = m_dictValuesLowPointDev[tg.m_id].m_id_TM
                        });

                        if (! (tg.m_TurnOnOff == StatisticCommon.TG.INDEX_TURNOnOff.UNKNOWN))
                        {
                            cntTGTurnUnknown --;

                            if (tg.m_TurnOnOff == StatisticCommon.TG.INDEX_TURNOnOff.ON)
                                cntTGTurnOn ++;
                            else
                                ;
                        }
                        else
                            ;
                    }
                }
                #endregion

                #region CUR_POWER
                if (IsValueValidate ((float)power_TM) == true) // дополн. проверить не зарегистрировано ли вкл./выкл. ТГ
                    if (!(power_TM < 1)) {
                        int situation = 0;

                        if ((cntTGTurnUnknown == 0) // кол-во ТГ с неизвестным состоянием = 0
                            && (cntTGTurnOn == cntPower_TMValues)) // кол-во ТГ, учтенных для подсчета общего знач. тек./мощн. ГТП = кол-ву вкл. ТГ
                        {
                            double absDiff = Math.Abs(power_TM - m_valuesHours[curHour].UDGe)
                                , lim = m_valuesHours[curHour].UDGe * ((double)TECComponentCurrent.m_dcKoeffAlarmPcur / 100);
                            if (absDiff > lim)
                            {
                                //EventReg(allTECComponents[indxTECComponents].m_id, -1);
                                if (power_TM < m_valuesHours[curHour].UDGe)
                                    situation = -1; //Меньше
                                else
                                    situation = 1; //Больше

                                EventReg?.Invoke (new TecViewAlarm.AlarmTecViewEventArgs(TECComponentCurrent.m_id
                                    , StatisticCommon.OICDAC.DbInterface.OIKParameter.UNKNOWN
                                    , new AlarmNotifyEventArgs.EventReason () {
                                        value = power_TM 
                                        , UDGe = m_valuesHours[curHour].UDGe
                                        , koeff = TECComponentCurrent.m_dcKoeffAlarmPcur }
                                    , DateTime.UtcNow
                                    , situation
                                    , listEventDetail));
                            }
                            else
                                ; //EventUnReg...
                        }
                        else
                            // обработаны не все значения тек./мощности ТГ_в_работе из состава ГТП
                            Logging.Logg().Warning(@"TecViewAlarm::AlarmRegistred (id=" + CurrentKey.Id + @") - обработаны не все значения тек./мощности ТГ_в_работе из состава ГТП", Logging.INDEX_MESSAGE.NOT_SET);
                    }
                    else
                        ; //Нет значений ИЛИ значения ограничены 1 МВт
                else
                    iRes = -102; //INDEX_WAITHANDLE_REASON.BREAK
                #endregion
            }

            return iRes;
        }

        public int AlarmRegistred (StatisticCommon.OICDAC.DbInterface.OIKParameter param)
        {
            int iRes = (int)ASUTP.Helper.HHandler.INDEX_WAITHANDLE_REASON.SUCCESS;

            Func<double, double, bool> predicate = (curr, prev) => {
                AdminAlarm.STATUS stat = AdminAlarm.STATUS.NAN;

                stat = AdminAlarm.GetStatus (param, (float)curr, (float)prev);

                return stat == AdminAlarm.STATUS.ERROR; //??? NAN
            };

            if (GetAlarmRegistredRequired (param.Translate()) == true)
                foreach (StatisticCommon.TG tg in allTECComponents.Find (comp => comp.m_id == CurrentKey.Id).ListLowPointDev) {
                    if (tg.m_TurnOnOff == TG.INDEX_TURNOnOff.ON) {
                        if (m_dictValuesLowPointDev[tg.m_id].m_valuesTM[param].IsAlarmed(predicate) == true)
                            // регистрация события сигнализации: мощн., частота
                            EventReg?.Invoke (new TecViewAlarm.AlarmTecViewEventArgs(tg.m_id
                                , param
                                , new AlarmNotifyEventArgs.EventReason() {
                                    value = m_dictValuesLowPointDev[tg.m_id].m_valuesTM[param].Data
                                    , UDGe = -1F //??? не используется
                                    , koeff = -1 //??? не используется
                                }
                                , DateTime.UtcNow
                                , 0 //AdminAlarm.STATUS.ERROR - и без значения очевидно - какое событие и ситуация
                                , new List<TecViewAlarm.AlarmTecViewEventArgs.EventDetail> () {
                                    new AlarmTecViewEventArgs.EventDetail() { id = tg.m_id, id_tm = -1, value = new value(m_dictValuesLowPointDev[tg.m_id].m_valuesTM[param].Previous) }
                                }));
                        else
                            ;
                    } else
                        ;
                }
            else
                ;

            return iRes;
        }
    }
}
