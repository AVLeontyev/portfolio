using System;
using System.IO;
using System.Data;
using System.Collections.Generic;
using System.Threading;
using System.Globalization; //CultureInfo
using System.ComponentModel;

using StatisticCommon;
using ASUTP.Helper;
using ASUTP.Database;
using ASUTP;
using ASUTP.PlugIn;
using ASUTP.Core;
using System.Linq;
using StatisticCommon.Contract.Alarm;
//using HClassLibrary;

namespace SAlarm.Service
{
    public partial class AdminAlarm : HHandlerQueue
    {
        /// <summary>
        /// Перечисление для режимов работы вкладки
        /// </summary>
        [Flags]
        public enum MODE { UNKNOWN, LAST_VALUES, REGISTER, NOTIFY = 0x4, LIST_REGISTER = 0x8, LIST_DATE = 0x10, EVENT_DETAIL = 0x20 };
        // Service - LAST_VALUES, REGISTER, LIST_REGISTER
        // Admin - NOTIFY, LIST_REGISTER, LIST_DATE, EVENT_DETAIL
        // ViewAlarm - LIST_DATE, EVENT_DETAIL
        // View - LAST_VALUES, LIST_DATE

        /// <summary>
        /// Класс для описания события сигнализаций (для отображения в таблице)
        /// </summary>
        public class ViewAlarmBase
        {
            public long m_id; //Идентификатор записи в ьаблице БД
            public int m_id_owner;
            public int m_id_component;
            public float m_value;
            public string m_str_name_shr_component;
        }
        
        /// <summary>
        /// Класс для описания события сигнализаций (для отображения в таблице основной информации о событии)
        /// </summary>
        public class ViewAlarmJournal : ViewAlarmBase
        {
            public TYPE_ALARM m_type;
            public string m_str_name_shr_type;
            public int m_id_user_registred;
            public DateTime? m_dt_registred;
            public int m_id_user_fixed;
            public DateTime? m_dt_fixed;
            public int m_id_user_confirmed;
            public DateTime? m_dt_confirmed;
            public int m_situation;
        }

        /// <summary>
        /// Структура для передачи значений для отображения
        ///  в таблицу детализации события сигнализации
        /// </summary>
        public class ViewAlarmDetail : ViewAlarmBase
        {
            public long m_id_event;
            public DateTime? m_last_changed_at;
        }

        /// <summary>
        /// Режим работы вкладки
        /// </summary>
        public MODE Mode;
        /// <summary>
        /// Шаблон для сохранения/обновления даты/времени в БД
        /// </summary>
        private static string s_strDateTimeFormat = @"yyyyMMdd HH:mm:ss.fffffff";

        /// <summary>
        /// Класс для хранения значений о событии сигнализации
        /// </summary>
        public class AlarmDbEventArgs : AlarmNotifyEventArgs
        {
            /// <summary>
            /// Идентификатор ...
            /// </summary>
            public long m_id;
            /// <summary>
            /// Идентификаторы пользователя зарегистрировавшего/подтвердившего/снявшего событие с оповещения
            /// </summary>
            public int m_id_user_registred
                , m_id_user_fixed
                , m_id_user_confirm;
            /// <summary>
            /// Дата/время подтверждения и снятия события с оповещения
            /// </summary>
            public DateTime? 
                m_dtFixed
                , m_dtConfirm;

            /// <summary>
            /// Конструктор - основной (с аргументами)
            /// </summary>
            /// <param name="rowEvt">Строка таблицы со значенями для инициализации полей/свойств</param>
            public AlarmDbEventArgs(DataRow rowEvt)
                : base((int)rowEvt[@"ID_COMPONENT"]
                    , ((TYPE_ALARM)(int)rowEvt[@"TYPE"]).Translate()
                    , new AlarmNotifyEventArgs.EventReason () { value = (float)rowEvt[@"value"], UDGe = float.NaN, koeff = decimal.MinusOne }
                    , (DateTime)rowEvt[@"DATETIME_REGISTRED"]
                    , (int)rowEvt[@"SITUATION"])
            {
                //Регистрация события
                m_id = (long)rowEvt[@"ID"];
                m_id_user_registred = (int)rowEvt[@"ID_USER_REGISTRED"];
                //Фиксация события
                if (! (rowEvt[@"ID_USER_FIXED"] is System.DBNull))
                    m_id_user_fixed = (int)rowEvt[@"ID_USER_FIXED"];
                else
                    m_id_user_fixed = -1;
                if (!(rowEvt[@"DATETIME_FIXED"] is System.DBNull))
                    m_dtFixed = (DateTime)rowEvt[@"DATETIME_FIXED"];
                else
                    m_dtFixed = null;
                //Подтверждение события
                if (!(rowEvt[@"ID_USER_CONFIRM"] is System.DBNull))
                    m_id_user_confirm = (int)rowEvt[@"ID_USER_CONFIRM"];
                else
                    m_id_user_confirm = -1;
                if (!(rowEvt[@"DATETIME_CONFIRM"] is System.DBNull))
                    m_dtConfirm = (DateTime)rowEvt[@"DATETIME_CONFIRM"];
                else
                    m_dtConfirm = null;
                //m_situation, [SUTUATION]
                //m_message_shr, [SUTUATION]
            }
        }

        /// <summary>
        /// Перечисление - индексы известных для обработки состояний
        /// </summary>
        public enum StatesMachine { Unknown 
            , ListDate, ListRegister, Detail, Insert, Retry, Fixed, Confirm
            , LastValues, CurPowerValues
        }

        /// <summary>
        /// Объект для учета событий сигнализации и их состояний
        /// </summary>
        private DictAlarmObject m_dictAlarmObject;
        /// <summary>
        /// Тип функции - для обработки события регистрации события (случая) сигнализаций из БД
        /// </summary>
        /// <param name="ev">Аргумент ...</param>
        public delegate void AlarmDbEventHandler(AlarmDbEventArgs ev);
        /// <summary>
        /// События для оповещения панели
        /// </summary>
        public event AlarmNotifyEventHandler EventAdd
            , EventRetry;
        /// <summary>
        /// Событие регистрации события (случая) сигнализаций из БД
        /// </summary>
        private event AlarmDbEventHandler EventReg;

        //private volatile bool m_bAlarmDbEventUpdated;
        /// <summary>
        /// Признак актуальности зарегистрированных событий сигнализаций из БД
        /// </summary>
        private ManualResetEvent m_mEvtAlarmDbEventUpdated;
        /// <summary>
        /// Таймер для запроса актуального перечня событий сигнализаций
        /// </summary>
        private System.Threading.Timer m_timerView;
        /// <summary>
        /// Тип делегата обработчика события по изменению текущей даты/диапазона_часов опроса событий зарегистрированных в БД
        /// </summary>
        /// <param name="ev">Аргумент при вызове метода</param>
        public delegate void DatetimeCurrentEventHandler(DatetimeCurrentEventArgs ev);

        /// <summary>
        /// Класс для объекта аргумента события
        /// </summary>
        public class DatetimeCurrentEventArgs : EventArgs
        {
            /// <summary>
            /// Дата, округленная до "полуночи"
            /// </summary>
            public DateTime Date;
            /// <summary>
            /// Номер часа(ов)
            /// </summary>
            public int HourBegin
                , HourEnd;
            /// <summary>
            /// Конструктор - основной (с аргументами)
            /// </summary>
            /// <param name="date">Дата, округленная до "полуночи"</param>
            /// <param name="iHourBegin">Номер часа начала</param>
            /// <param name="iHourEnd">Номер часа окончания</param>
            public DatetimeCurrentEventArgs (DateTime date, int iHourBegin, int iHourEnd)
            {
                this.Date = date;
                this.HourBegin = iHourBegin;
                this.HourEnd = iHourEnd;
            }
        }

        public class CurPowerEventArgs : EventArgs
        {
            public DateTime ReqDate;

            //public int IdSource;

            public int ReqInterval;
        }

        private DatetimeCurrentEventArgs m_dtCurrent;
        /// <summary>
        /// Признак вкл./выкл. объекта
        /// </summary>
        private bool m_bWorkChecked;
        /// <summary>
        /// Класс для получения данных из БД
        /// </summary>
        internal class HandlerDb : ASUTP.Helper.HHandlerDb
        {
            /// <summary>
            /// Перечисление
            /// </summary>
            public enum StatesMachine { CurrentTime
                , ListEvents, EventDetail
                , InsertEventMain, InsertEventDetail
                , RetryEvent
                , UpdateEventFixed, UpdateEventConfirm
                , LastValues_TM_Gen, LastValues_TM_Freq
                , Hours_TM, CurrentMinutes_TM, PPBRValues, AdminValues
            }
            /// <summary>
            /// Параметры соединения с БД_значений
            /// </summary>
            private ConnectionSettings m_connSett;
            /// <summary>
            /// Идентификатор установленного, активного соединения с БД_значений
            /// </summary>
            private int IdListener { get { return m_dictIdListeners[0][0]; } }
            /// <summary>
            /// Перечисление - индексы объектов синхронизации для обмена данными (результатом) обработки событий
            /// </summary>
            public enum INDEX_SYNC_STATECHECKRESPONSE { UNKNOWN = -1, RESPONSE, ERROR, WARNING
                ,  COUNT_INDEX_SYNC_STATECHECKRESPONSE }
            /// <summary>
            /// Объекты синхронизации для обмена данными (результатом) обработки событий
            /// </summary>
            public AutoResetEvent [] m_arSyncStateCheckResponse;
            /// <summary>
            /// Таблица для обмена данными (результатом) обработки событий
            /// </summary>
            private DataTable m_tableResponse;
            /// <summary>
            /// Дата/время (дата) запроса списка событий
            /// </summary>
            private DateTime m_dtCurrent
                /// <summary>
                /// Дата/время сервера
                /// </summary>
                , m_dtServer;
            /// <summary>
            /// Индекс часа начала периода запроса списка событий в сутках
            /// </summary>
            private int m_iHourBegin
                /// <summary>
                /// Индекс часа окончания периода запроса списка событий в сутках
                /// </summary>
                , m_iHourEnd;
            /// <summary>
            /// Идентификатор записи в таблице БД_значений о событии сигнализации
            /// </summary>        
            private object m_objIntermediateValue;
            /// <summary>
            /// Информация о событии сигнализации
            /// </summary>
            private object m_objArgument;

            public HandlerDb(ConnectionSettings connSett)
            {
                m_connSett = connSett;

                m_arSyncStateCheckResponse = new AutoResetEvent[(int)INDEX_SYNC_STATECHECKRESPONSE.COUNT_INDEX_SYNC_STATECHECKRESPONSE]
                {
                    new AutoResetEvent (false)
                    , new AutoResetEvent (false)
                    , new AutoResetEvent (false)
                };
            }

            public override void Start()
            {
                //ClearValues();
                base.Start ();

                //??? может быть раньше, чем вызов базового метода
                StartDbInterfaces ();

                //Logging.Logg ().Debug ($@"AdminAlarm.HandlerDb::Start () - ...", Logging.INDEX_MESSAGE.NOT_SET);
            }

            public override void Stop()
            {
                m_arSyncStateCheckResponse[(int)INDEX_SYNC_STATECHECKRESPONSE.WARNING].Set ();
                
                base.Stop();
            }

            public override bool Activate(bool active)
            {
                bool bRes = base.Activate(active);

                //Logging.Logg ().Debug ($@"AdminAlarm.HandlerDb::Activate (active={active}) - Result={bRes}...", Logging.INDEX_MESSAGE.NOT_SET);

                return bRes;
            }

            public override void StartDbInterfaces()
            {
                m_dictIdListeners.Add(0, new int[] { -1 });
                m_dictIdListeners[0][0] = DbSources.Sources().Register(m_connSett, true, @"ViewAlarm");
                Console.WriteLine(@"AdminAlarm.HHandlerDb::StartDbInterfaces (active=true) - iListenerId=" + m_dictIdListeners[0][0]);
            }

            protected override int StateCheckResponse(int state, out bool error, out object table)
            {
                int iRes = 0;

                error = false;
                table = null;

                switch ((StatesMachine)state)
                {
                    case StatesMachine.CurrentTime:
                    case StatesMachine.ListEvents:
                    case StatesMachine.EventDetail:
                    case StatesMachine.InsertEventMain:
                    case StatesMachine.UpdateEventFixed:
                    case StatesMachine.UpdateEventConfirm:
                    case StatesMachine.RetryEvent:

                    #region Опрос данных
                    case StatesMachine.LastValues_TM_Gen:
                    case StatesMachine.LastValues_TM_Freq:
                    case StatesMachine.Hours_TM:
                    case StatesMachine.CurrentMinutes_TM:
                    case StatesMachine.PPBRValues:
                    case StatesMachine.AdminValues:
                    #endregion

                        iRes = response(out error, out table);
                        break;
                    case StatesMachine.InsertEventDetail:
                        break;
                    default:
                        iRes = -1;
                        break;
                }

                error = !(iRes == 0);

                return iRes;
            }

            protected override int StateRequest(int state)
            {
                int iRes = 0;

                //Logging.Logg ().Debug ($@"AdminAlarm.HandlerDb::StateRequest (state={(StatesMachine)state}) - ...", Logging.INDEX_MESSAGE.NOT_SET);

                CurPowerEventArgs arg;

                switch ((StatesMachine)state)
                {
                    case StatesMachine.CurrentTime:
                        requestCurrentTime();
                        break;
                    case StatesMachine.ListEvents:
                        requestListEvents();
                        break;
                    case StatesMachine.InsertEventMain:
                        requestInsertEventMain();
                        break;
                    case StatesMachine.InsertEventDetail:
                        requestInsertEventDetail();
                        break;
                    case StatesMachine.RetryEvent:
                        requestRetryEvent();
                        break;
                    case StatesMachine.UpdateEventFixed:
                        requestUpdateEventFixed();
                        break;
                    case StatesMachine.UpdateEventConfirm:
                        requestUpdateEventConfirm();
                        break;
                    case StatesMachine.EventDetail:
                        requestEventDetail();
                        break;

                    #region Опрос данных
                    case StatesMachine.LastValues_TM_Gen:
                        requestLastValues (ID_SIGN_SOTIASSO.APOWER);
                        break;
                    case StatesMachine.LastValues_TM_Freq:
                        requestLastValues (ID_SIGN_SOTIASSO.FREQ);
                        break;
                    case StatesMachine.Hours_TM:
                        arg = m_objArgument as CurPowerEventArgs;
                        requestHours_TM (arg.ReqDate/*, arg.IdSource*/);
                        break;
                    case StatesMachine.CurrentMinutes_TM:
                        arg = m_objArgument as CurPowerEventArgs;
                        requestCurrentMinutes_TM (arg.ReqDate/*, arg.IdSource*/, arg.ReqInterval);
                        break;
                    case StatesMachine.PPBRValues:
                        arg = m_objArgument as CurPowerEventArgs;
                        requestPPBRValues (arg.ReqDate);
                        break;
                    case StatesMachine.AdminValues:
                        arg = m_objArgument as CurPowerEventArgs;
                        requestAdminValues (arg.ReqDate);
                        break;
                    #endregion

                    default:
                        break;
                }

                //Logging.Logg().Debug(@"ViewAlarm::StateRequest () - state=" + ((StatesMachine)state).ToString() + @", result=" + bRes.ToString() + @" - вЫход...");

                return iRes;
            }

            protected override int StateResponse(int state, object obj)
            {
                int iRes = 0;

                CurPowerEventArgs arg;
                Tuple<DateTime, TYPE_ALARM> keyEventValuesDone;

                switch ((StatesMachine)state)
                {
                    case StatesMachine.CurrentTime:
                        if ((iRes = responseCurrentTime (obj as DataTable)) == 0)
                            EventCurrentTimeDone?.Invoke (obj as DataTable);
                        else
                            ;
                        break;
                    case StatesMachine.InsertEventMain:
                        responseInsertEventMain(obj as DataTable);
                        break;
                    case StatesMachine.ListEvents:
                    case StatesMachine.EventDetail:
                    case StatesMachine.InsertEventDetail:
                    case StatesMachine.UpdateEventFixed:
                    case StatesMachine.UpdateEventConfirm:
                        // обработки ответа не требуется
                        break;
                    case StatesMachine.RetryEvent:
                        EventRetryDone?.Invoke ( (long)(obj as DataTable).Rows[0][@"ID"]
                            , (int)(obj as DataTable).Rows[0][@"ID_COMPONENT"]
                            , (DateTime)(obj as DataTable).Rows[0][@"DATETIME_REGISTRED"]
                            , (TYPE_ALARM)(int)(obj as DataTable).Rows[0][@"TYPE"]
                        );
                        break;

                    #region Опрос данных
                    case StatesMachine.LastValues_TM_Gen:
                    case StatesMachine.LastValues_TM_Freq:
                    case StatesMachine.Hours_TM:
                    case StatesMachine.CurrentMinutes_TM:
                    case StatesMachine.PPBRValues:
                    case StatesMachine.AdminValues:
                        if ((Equals (m_objArgument, null) == false)
                            && (typeof (EventArgs).IsAssignableFrom (m_objArgument.GetType ()) == true)) {
                            arg = m_objArgument as CurPowerEventArgs;
                            keyEventValuesDone = Tuple.Create (arg.ReqDate, ((StatesMachine)state).Translate ());
                        } else
                            keyEventValuesDone = Tuple.Create (DateTime.MaxValue, ((StatesMachine)state).Translate ());
                        // отправить без обработки и не ожидать крайнего состояния
                        // , т.к. совместить результаты запросов невозможно
                        EventValuesDone?.Invoke (keyEventValuesDone, (obj as DataTable).Copy());
                        break;
                    #endregion

                    default:
                        break;
                }

                //Проверить крайнее ли обрабатывается состояние
                if (isLastState (state) == true)
                {
                    //Проверить возможность сохранения результата запроса
                    if (! (obj == null))
                        //Сохранить результат в "выходную" переменную
                        m_tableResponse = (obj as DataTable).Copy();
                    else
                        ;
                    //Указать, что ответ готов
                    m_arSyncStateCheckResponse[(int)INDEX_SYNC_STATECHECKRESPONSE.RESPONSE].Set();
                }
                else
                    ;

                //Logging.Logg().Debug(@"ViewAlarm::StateRequest () - state=" + ((StatesMachine)state).ToString() + @", result=" + bRes.ToString() + @" - вЫход...");

                return iRes;
            }

            protected override HHandler.INDEX_WAITHANDLE_REASON StateErrors(int state, int req, int res)
            {
                m_arSyncStateCheckResponse[(int)INDEX_SYNC_STATECHECKRESPONSE.ERROR].Set();
                
                Logging.Logg().Error(@"ViewAlarm::StateErrors () - state=" + ((StatesMachine)state).ToString() + @", req=" + req.ToString() + @", res=" + res.ToString(), Logging.INDEX_MESSAGE.NOT_SET);

                return INDEX_WAITHANDLE_REASON.SUCCESS;
            }

            protected override void StateWarnings(int state, int req, int res)
            {
                m_arSyncStateCheckResponse[(int)INDEX_SYNC_STATECHECKRESPONSE.WARNING].Set ();
                
                Logging.Logg().Warning(@"ViewAlarm::StateWarnings () - state=" + ((StatesMachine)state).ToString() + @", req=" + req.ToString() + @", res=" + res.ToString(), Logging.INDEX_MESSAGE.NOT_SET);
            }

            public override void ClearValues()
            {//??? - необязательное наличие - удалить из 'HHandlerDb'
                m_objIntermediateValue = null;
                m_objArgument = null;
                ////??? abstract
                //base.ClearValues ();
            }

            public int Response(out bool error, out object table)
            {
                int iRes = 0;

                error = false;
                table = m_tableResponse;

                return iRes;
            }

            /// <summary>
            /// Выполнить запрос даты/времени на сервере
            /// </summary>
            protected void requestCurrentTime()
            {
                GetCurrentTimeRequest(DbTSQLInterface.getTypeDB(m_connSett.port), IdListener);
            }

            /// <summary>
            /// Обработать рез-т получения даты/времени на сервере
            /// </summary>
            /// <param name="tableRes">Результат запроса - значение даты/времени</param>
            /// <returns>Результат (не)получения метки даты/времени</returns>
            private int responseCurrentTime(DataTable tableRes)
            {
                int iRes = Equals (tableRes, null) == false
                    ? tableRes.Rows.Count == 1
                        ? 0
                            : -1
                                : 1;

                if (iRes == 0)
                    m_dtServer = (DateTime)tableRes.Rows[0][0];
                else
                    Logging.Logg().Error(@"AdminAlarm.HandlerDb::GetCurrentTimeResponse () - таблица не содержит ни одной строки ..."
                        , Logging.INDEX_MESSAGE.NOT_SET);

                return iRes;
            }

            /// <summary>
            /// Выполнить запрос для получения перечня событий сигнализаций
            ///  за указанный период времени (дата/часы начала/окончания)
            /// </summary>
            private void requestListEvents()
            {
                Request(IdListener
                    , @"SELECT * FROM [dbo].[AlarmEvent]"
                        + @" WHERE [DATETIME_REGISTRED] BETWEEN '"
                            + (m_dtCurrent.AddHours(m_iHourBegin) - HDateTime.TS_MSK_OFFSET_OF_UTCTIMEZONE).ToString(@"yyyyMMdd HH:mm:ss") + @"' AND '"
                            + (m_dtCurrent.AddHours(m_iHourEnd) - HDateTime.TS_MSK_OFFSET_OF_UTCTIMEZONE).ToString(@"yyyyMMdd HH:mm:ss") + @"'"
                        + @" ORDER BY [DATETIME_REGISTRED]");
            }

            private void requestEventDetail()
            {
                long id = (long)m_objArgument;

                Request(IdListener
                    , @"SELECT * FROM [dbo].[AlarmDetail] WHERE [ID_EVENT]=" + id);
            }

            /// <summary>
            /// Сформировать содержимое запроса к БД и отправить для выполнения
            ///  , по сложивжейся традиции, несмотря на 'Get', тип возвращаемого значения 'void'
            /// </summary>
            private void requestInsertEventMain()
            {
                TecViewAlarm.AlarmTecViewEventArgs arg = m_objArgument as TecViewAlarm.AlarmTecViewEventArgs;
                int id_user = HUsers.Id; //ID_USER
                double val =
                    //(arg.Mode == FormChangeMode.MODE_TECCOMPONENT.GTP) ? -1F :
                    //    (arg.Mode == FormChangeMode.MODE_TECCOMPONENT.TG) ? arg.m_listEventDetail[0].value :
                    //        -2F
                    arg.m_reason.value
                            ; //VALUE
                string strDTRegistred = arg.m_dtRegistred.GetValueOrDefault().ToString(s_strDateTimeFormat); //DATETIME_REGISTRED
                //Запрос для вставки записи о событии сигнализации
                string query = "INSERT INTO [dbo].[AlarmEvent] ([ID_COMPONENT],[TYPE],[VALUE],[DATETIME_REGISTRED],[ID_USER_REGISTRED],[DATETIME_FIXED],[ID_USER_FIXED],[DATETIME_CONFIRM],[ID_USER_CONFIRM],[CNT_RETRY],[INSERT_DATETIME],[SITUATION]) VALUES"
                    + @" ("
                        + arg.m_id_comp + @", " //ID_COMPONENT
                        + (int)arg.Type + @", " //TYPE                        
                        + val.ToString(@"F3", CultureInfo.InvariantCulture) + @", " //VALUE
                        + @"'" + strDTRegistred + @"', " //DATETIME_REGISTRED
                        + id_user + @", " //ID_USER_REGISTRED
                        + "NULL" + @", " //DATETIME_FIXED
                        + "NULL" + @", " //ID_USER_FIXED
                        + "NULL" + @", " //DATETIME_CONFIRM
                        + "NULL" + @", " //ID_USER_CONFIRM
                        + 0 + @", " //CNT_RETRY
                        + "GETDATE ()" + @", " //INSERT_DATETIME
                        + @"'" + arg.m_situation + @"'" //SITUATION
                    + @")";
                query += @";";
                //??? Переход на новую строку
                //query += "\r\n";
                query += Environment.NewLine;
                //Запрос на получение идентификатора вставленной записи
                query += @"SELECT * FROM [dbo].[AlarmEvent] WHERE "
                    + @"[ID_COMPONENT]=" + arg.m_id_comp
                    + @" AND [TYPE]=" + (int)arg.Type                    
                    + @" AND [DATETIME_REGISTRED]='" + strDTRegistred + @"'"
                    + @" AND [ID_USER_REGISTRED]=" + id_user;
                query += @";";

                Request(IdListener, query);
            }
            /// <summary>
            /// Обработать (промежуточный) рез-т запроса вставки записи - основная информация о событии сигнализации
            ///  , получить идентификатор вставленной записи
            /// </summary>
            /// <param name="obj">Идентификатор вставленной записи</param>
            private void responseInsertEventMain(object obj)
            {
                // сохранить значени в промежуточную переменную
                // для использования в последущем запросе
                // при обработке следующего состояния для текущей группы состояний
                m_objIntermediateValue = (long)(obj as DataTable).Rows[0][@"ID"];
            }

            public event Action<long, int, DateTime, TYPE_ALARM> EventRetryDone;
            public event Action<Tuple <DateTime, TYPE_ALARM>, DataTable> EventValuesDone;
            public event Action<DataTable> EventCurrentTimeDone;

            /// <summary>
            /// Выполнить запрос на вставку дополнительной информации для события сигнализаций
            /// </summary>
            private void requestInsertEventDetail()
            {
                TecViewAlarm.AlarmTecViewEventArgs arg = m_objArgument as TecViewAlarm.AlarmTecViewEventArgs;
                long id = (long)m_objIntermediateValue;
                string query = string.Empty;

                if (arg.m_listEventDetail.Count > 0) {
                    foreach (TecViewAlarm.AlarmTecViewEventArgs.EventDetail detail in arg.m_listEventDetail)
                    {
                        if (detail.value.Data > 0)
                        {
                            if (!(id < 0))
                            {
                                query += @"(";

                                query += id + @", ";
                                query += detail.id + @", ";
                                query += detail.value.Data.ToString(@"F3", CultureInfo.InvariantCulture) + @", ";
                                query += @"'" + detail.value.Stamp.ToString(s_strDateTimeFormat) + @"', ";
                                query += detail.id_tm + @", ";
                                query += @"GETDATE()";

                                query += @"),";
                            }
                            else
                                throw new Exception($@"ViewAlarm.HandlerDb::GetInsertEventDetailRequest () - idEventMain={id} некорректный идентификатор...");
                        }
                        else
                            ;
                    }

                    if (string.IsNullOrEmpty (query) == false) {
                        //Не учитывать крайнюю запятую
                        query = @"INSERT INTO [dbo].[AlarmDetail] VALUES " + query.Substring (0, query.Length - 1);

                        Request (IdListener, query);
                    } else
                        throw new Exception ($@"ViewAlarm.HandlerDb::GetInsertEventDetailRequest () - idEventMain={id} список детализации...");
                } else
                    throw new Exception ($@"ViewAlarm.HandlerDb::GetInsertEventDetailRequest () - idEventMain={id}, отсутствует детализщация...");
            }

            private void requestRetryEvent()
            {
                AlarmNotifyEventArgs arg = m_objArgument as AlarmNotifyEventArgs;
                string query = string.Empty
                    , where = @"WHERE [ID_COMPONENT]=" + arg.m_id_comp
                        + @" AND [DATETIME_REGISTRED]='" + arg.m_dtRegistred.GetValueOrDefault().ToString(s_strDateTimeFormat) + @"'"
                        + @" AND [TYPE]=" + (int)arg.Type;

                query = @"UPDATE [dbo].[AlarmEvent] SET [ID_USER_FIXED]=NULL, [DATETIME_FIXED]=NULL "
                    + where;
                query += @"; ";
                query += Environment.NewLine;
                query += @"SELECT * FROM [dbo].[AlarmEvent] "
                    + where;

                Request(IdListener, query);
            }
            /// <summary>
            /// Выполнить запрос по обновлению информации о событии сигнализаций
            ///  обновление даты/времени ФИКСАЦИИ события
            /// </summary>
            private void requestUpdateEventFixed()
            {
                AlarmNotifyEventArgs arg = m_objArgument as AlarmNotifyEventArgs;
                string query = string.Empty
                    , where = @"WHERE [ID_COMPONENT]=" + arg.m_id_comp
                        + @" AND [DATETIME_REGISTRED]='" + arg.m_dtRegistred.GetValueOrDefault().ToString (s_strDateTimeFormat) + @"'"
                        + @" AND [TYPE]=" + (int)arg.Type;

                query = @"UPDATE [dbo].[AlarmEvent] SET [ID_USER_FIXED]=" + HUsers.Id + @", [DATETIME_FIXED]=GETUTCDATE() "
                    + where;
                query += @"; ";
                query += Environment.NewLine;
                query += @"SELECT * FROM [dbo].[AlarmEvent] "
                    + where;

                Request(IdListener, query);
            }
            /// <summary>
            /// Выполнить запрос по обновлению информации о событии сигнализаций
            ///  обновление даты/времени ПОДТВЕРЖДЕНИЯ события
            /// </summary>
            private void requestUpdateEventConfirm()
            {
                long id = (long)m_objArgument;
                string query = string.Empty
                    , where = @"WHERE [ID]=" + id;

                query = @"UPDATE [dbo].[AlarmEvent] SET [ID_USER_CONFIRM]=" + HUsers.Id + @", [DATETIME_CONFIRM]=GETUTCDATE() "
                    + where;
                query += @"; ";
                query += Environment.NewLine;
                query += @"SELECT * FROM [dbo].[AlarmEvent] "
                    + where;

                Request(IdListener, query);
            }
            /// <summary>
            /// Выполнить запрос (группу запросов) для получения актуального списка событий сигнализаций
            ///  за указанную дату и часы (начало/окончание)
            /// </summary>
            /// <param name="dtCurrent">Дата для запроса</param>
            /// <param name="iHourBegin">Номер часа начала</param>
            /// <param name="iHourEnd">Номер часа окончания</param>
            public void Refresh(DateTime dtCurrent, int iHourBegin, int iHourEnd)
            {
                m_dtCurrent = dtCurrent;
                m_iHourBegin = iHourBegin;
                m_iHourEnd = iHourEnd;

                refresh ();
            }
            /// <summary>
            /// Сформировать группу состояний для актуализации списка событий сигнализаций
            /// </summary>
            private void refresh()
            {
                lock (this)
                {
                    ClearValues();
                    ClearStates();

                    AddState((int)StatesMachine.CurrentTime);
                    AddState((int)StatesMachine.ListEvents);

                    Run(@"ViewAlarm.HHandlerDb::Refresh");
                }
            }
            /// <summary>
            /// Сформировать группу состояний для получения дополнительной информации о
            ///  событии сигнализаций
            /// </summary>
            /// <param name="id">Идентификатор события сигнализаций</param>
            public void Detail(object id)
            {
                lock (this)
                {
                    ClearValues();
                    ClearStates();

                    m_objArgument = id;

                    AddState((int)StatesMachine.CurrentTime);
                    AddState((int)StatesMachine.EventDetail);

                    Run(@"ViewAlarm::Detail");
                }
            }
            /// <summary>
            /// Сформировать группу состояний для вставки основной информации о
            ///  событии сигнализаций
            /// </summary>
            /// <param name="ev">Информация о событии сигнализаций</param>
            public void Insert(TecViewAlarm.AlarmTecViewEventArgs ev)
            {
                lock (this)
                {
                    ClearValues();
                    ClearStates();

                    m_objArgument = ev;

                    AddState((int)StatesMachine.CurrentTime);
                    AddState((int)StatesMachine.InsertEventMain);
                    if ((Equals (ev.m_listEventDetail, null) == false)
                        && (ev.m_listEventDetail.Count > 0))
                        AddState ((int)StatesMachine.InsertEventDetail);
                    else
                        ;

                    Run(@"ViewAlarm::Insert");
                }
            }

            public void Retry(TecViewAlarm.AlarmTecViewEventArgs ev)
            {
                lock (this)
                {
                    ClearValues();
                    ClearStates();

                    m_objArgument = ev;

                    AddState((int)StatesMachine.CurrentTime);
                    AddState((int)StatesMachine.RetryEvent);

                    Run(@"ViewAlarm::Retry");
                }
            }
            /// <summary>
            /// Сформировать группу состояний для обновлнеия основной информации о
            ///  событии оповещения (ФИКСАЦИЯ)
            /// </summary>
            /// <param name="ev">Информация о событии оповещния</param>
            public void Fixed(AlarmNotifyEventArgs ev)
            {
                lock (this)
                {
                    ClearValues();
                    ClearStates();

                    m_objArgument = ev;

                    AddState((int)StatesMachine.CurrentTime);
                    AddState((int)StatesMachine.UpdateEventFixed);

                    Run(@"AdminAlarm::Fixed");
                }
            }
            /// <summary>
            /// Сформировать группу состояний для обновлнеия основной информации о
            ///  событии сигнализаций (ПОДТВЕРЖДЕНИЕ)
            /// </summary>
            /// <param name="id">Идентификатор события сигнализаций</param>
            public void Confirm(object id)
            {
                lock (this)
                {
                    ClearValues();
                    ClearStates();

                    m_objArgument = id;

                    AddState((int)StatesMachine.CurrentTime);
                    AddState((int)StatesMachine.UpdateEventConfirm);

                    Run(@"ViewAlarm::Fixed");
                }
            }

            #region Опрос значений
            public void LastValues (bool bIsLastValuesTMFreq)
            {
                lock (this)
                {
                    ClearValues();
                    ClearStates();
                    //???
                    //m_objArgument = id;

                    AddState((int)StatesMachine.CurrentTime);
                    AddState((int)StatesMachine.LastValues_TM_Gen);
                    if (bIsLastValuesTMFreq == true)
                        AddState ((int)StatesMachine.LastValues_TM_Freq);
                    else
                        ;

                    Run(@"AdminAlarm.HandlerDb::LastValues");
                }
            }

            public void CurPowerValues (CurPowerEventArgs ev)
            {
                lock (this)
                {
                    ClearValues();
                    ClearStates();

                    m_objArgument = ev;

                    AddState((int)StatesMachine.CurrentTime);
                    AddState((int)StatesMachine.Hours_TM);
                    AddState((int)StatesMachine.CurrentMinutes_TM);
                    AddState((int)StatesMachine.PPBRValues);
                    AddState((int)StatesMachine.AdminValues);

                    Run(@"AdminAlarm.HandlerDb::RDGValues");
                }
            }

            private enum ID_SIGN_SOTIASSO { APOWER = 10, FREQ = 12 }

            private void requestLastValues (ID_SIGN_SOTIASSO sign)
            {
                //??? строго в ~ с 'TEC::currentTMRequest'
                Request (IdListener, $@"SELECT [ID_SIGNAL] as [KKS_NAME], [ID_AREA], [ID_TEC], [DATETIME] as [last_changed_at], [VALUE], [ID_SOURCE], [QUALIFY], [UPDATE_DATETIME]
                    FROM [CURRENT_VALUES]
                    WHERE [ID_SIGNAL] LIKE N'%_{(int)sign}_%'"
                );
            }

            private void requestHours_TM (DateTime dtReq/*, int id_source*/)
            {
                //TODO: ID_SOURCE исключается, т.к. запрос общий для всех подразделений
                    //WHERE
                    //    ID_SOURCE = { id_source }
                //TODO: WHERE ID_AREA, ID_TEC

                Request (IdListener, $@"SELECT [KKS_NAME] as [KKS_NAME], [ID_AREA], [ID_TEC], AVG ([VALUE]) AS [VALUE], SUM ([VALUE] / (60 / 3)) as [VALUE0], SUM ([tmdelta]) as [tmdelta], DATEPART (HOUR, [last_changed_at]) as [HOUR], COUNT(*) as [CNT]
			        FROM (
				        SELECT [KKS_NAME] as [KKS_NAME], [ID_AREA], [ID_TEC], AVG ([VALUE]) as [VALUE], SUM ([tmdelta]) as [tmdelta], [last_changed_at], (DATEPART (MINUTE, DATEADD (HH, DATEDIFF (HH, GETUTCDATE (), GETDATE()), [last_changed_at])) / 3) as [MINUTE]
					        FROM (
						        SELECT [KKS_NAME] as [KKS_NAME], [ID_AREA], [ID_TEC], [Value] as [VALUE], [tmdelta] as [tmdelta], DATEADD (MINUTE, - DATEPART (MINUTE, DATEADD (HH, DATEDIFF (HH, GETUTCDATE (), GETDATE()), [last_changed_at])) % 3, DATEADD (HH, DATEDIFF (HH, GETUTCDATE (), GETDATE()), [last_changed_at])) as [last_changed_at]
							        FROM [dbo].[ALL_PARAM_SOTIASSO_0_KKS]
							        WHERE
								        [KKS_NAME] LIKE N'%_10_%'
								        AND [Value] > 1
								        AND [last_changed_at] BETWEEN DATEADD (HH, DATEDIFF (HH, GETDATE (), GETUTCDATE()), N'{dtReq.ToString("yyyyMMdd HH:mm:ss.fff")}') AND DATEADD (HH, DATEDIFF (HH, GETDATE (), GETUTCDATE()), N'{dtReq.AddDays(1).AddMilliseconds(-2).ToString("yyyyMMdd HH:mm:ss.fff")}')
							        ) t0
						        GROUP BY [KKS_NAME], [ID_AREA], [ID_TEC], [last_changed_at], DATEPART (MINUTE, DATEADD (HH, DATEDIFF (HH, GETUTCDATE (), GETDATE()), [last_changed_at])
					        )
				        ) t1
		        GROUP BY  [KKS_NAME], [ID_AREA], [ID_TEC], DATEPART (HOUR, [last_changed_at])");
            }

            private void requestCurrentMinutes_TM (DateTime dtReq/*, int id_source*/, int interval)
            {
                //TODO: ID_SOURCE исключается, т.к. запрос общий для всех подразделений
                //WHERE ID_SOURCE = { id_source }" //m_IdSOTIASSOLinkSourceTM
                //TEC.s_SourceSOTIASSO == SOURCE_SOTIASSO.AVERAGE
                //TODO: WHERE ID_AREA, ID_TEC

                Request (IdListener, $@"SELECT [KKS_NAME] as [KKS_NAME], [ID_AREA], [ID_TEC], AVG ([VALUE]) AS [VALUE], SUM ([VALUE] / (60 / " + interval + @")) as [VALUE0], SUM ([tmdelta]) as [tmdelta]"
                            + @", DATEADD (HH, DATEDIFF (HH, GETUTCDATE (), GETDATE()), [last_changed_at]) as [last_changed_at]"
	                        + @", (DATEPART (MINUTE, DATEADD (HH, DATEDIFF (HH, GETUTCDATE (), GETDATE()), [last_changed_at])) / " + interval + @") as [MINUTE]"
                            + @", COUNT (*) as [CNT]"
                        + @" FROM ("
                            + @"SELECT [KKS_NAME] as [KKS_NAME], [ID_AREA], [ID_TEC], [Value] as [VALUE], [tmdelta] as [tmdelta]"
                                + @", DATEADD (MINUTE, - DATEPART (MINUTE, DATEADD (HH, DATEDIFF (HH, GETUTCDATE (), GETDATE()), [last_changed_at])) % " + interval + @", DATEADD (HH, DATEDIFF (HH, GETUTCDATE (), GETDATE()), [last_changed_at])) as [last_changed_at]"
	                            + @" FROM [dbo].[ALL_PARAM_SOTIASSO_0_KKS]"
                                + $@" WHERE"
                                    + @" [Value] > 1"
		                            //--Привести дату/время к UTC (уменьшить на разность с UTC)
                                    + @" AND [last_changed_at] BETWEEN DATEADD (HH, DATEDIFF (HH, GETDATE (), GETUTCDATE()), N'" + dtReq.ToString(@"yyyyMMdd HH:mm:00.000") + @"')"
                                         + @" AND DATEADD (HH, DATEDIFF (HH, GETDATE (), GETUTCDATE()), N'" + dtReq.AddHours(1).AddMilliseconds(-2).ToString(@"yyyyMMdd HH:mm:ss.fff") + @"')"
                                + @") t0"
                        + @" GROUP BY [KKS_NAME], [ID_AREA], [ID_TEC], DATEADD (HH, DATEDIFF (HH, GETUTCDATE (), GETDATE()), [last_changed_at]), DATEPART (MINUTE, DATEADD (HH, DATEDIFF (HH, GETUTCDATE (), GETDATE()), [last_changed_at]))"
                    + @" ORDER BY [last_changed_at], [KKS_NAME]");
            }

            private void requestPPBRValues (DateTime dtReq)
            {
                Request (IdListener, $@"SELECT * FROM [{StatisticCommon.Constants.CFG_TABLENAME_PPBRVALUES}]"
                    + $@" WHERE NOT [DATE_TIME] < N'{dtReq.ToString(@"yyyyMMdd HH:mm:00.000")}' AND NOT [DATE_TIME] > N'{dtReq.ToString(@"yyyyMMdd HH:mm:00.000")}'");
            }

            private void requestAdminValues (DateTime dtReq)
            {
                Request (IdListener, $@"SELECT * FROM [{StatisticCommon.Constants.CFG_TABLENAME_ADMINVLUES}]"
                    + $@" WHERE NOT [DATE] < N'{dtReq.ToString(@"yyyyMMdd HH:mm:00.000")}' AND NOT [DATE] > N'{dtReq.ToString(@"yyyyMMdd HH:mm:00.000")}'");
            }
            #endregion
        }
        /// <summary>
        /// Объект для получения данных из БД
        /// </summary>
        private AdminAlarm.HandlerDb m_handlerDb;
        /// <summary>
        /// Событие для отправки списка событий/детализации сигнализаций клиентам
        /// </summary>
        public event DelegateObjectFunc EventListEventDate
            , EventDetailEvents;

        public Action<IEnumerable<StatisticCommon.OICDAC.DbInterface.RequestResult>> EventListRequestResult;
        /// <summary>
        /// Объект потока для обработки рез-та запроса
        ///  на получение списка событий сигнализаций
        /// </summary>
        private BackgroundWorker m_threadListRegisterResponse;

        private Dictionary<StatesMachine, Action<IDataHost, object [], DataTable>> _dictActionStateResponseHandlers;

        private TYPE_ALARM _runable;

        /// <summary>
        /// Конструктор - основной (с параметрами)
        /// </summary>
        /// <param name="connSett">Параметры соединения с БД_значений</param>
        /// <param name="mode">Режим работы объекта</param>
        /// <param name="ev">Инициализация значений даты, часов начало, окончания запроса списка событий</param>
        /// <param name="bWorkChecked">Признак необходимости: для SERVICE - (не)регистрировать события; для ADMIN - (не)оповещать о возникновении событий; для VIEW - ??? не имеет значения</param>
        public AdminAlarm (ConnectionSettings connSett, MODE mode, DatetimeCurrentEventArgs ev, TYPE_ALARM runable, bool bWorkChecked)
            : base()
        {
            Mode = mode;
            m_dtCurrent = ev;
            _runable = runable;
            m_bWorkChecked = bWorkChecked;

            initializeRules (runable);

            lockValue = new object();

            m_dictAlarmObject = new DictAlarmObject();
            EventReg += new AlarmDbEventHandler(onEventReg);

            //m_bAlarmDbEventUpdated = false;
            m_mEvtAlarmDbEventUpdated = new ManualResetEvent (true);

            m_handlerDb = new AdminAlarm.HandlerDb(connSett);
            m_handlerDb.EventRetryDone += handlerDb_onEventRetryDone;

            //Инициализировать таймер для оповещение_список/оповещение_сигнал
            m_timerView = new System.Threading.Timer(new TimerCallback(fTimerView_Tick), null, Timeout.Infinite, Timeout.Infinite);

            m_timerAlarm =
                new System.Threading.Timer(new TimerCallback(fTimerAlarm_Tick), null, Timeout.Infinite, Timeout.Infinite)
                //new System.Windows.Forms.Timer ()
                ;
            //m_timerAlarm.Tick += new EventHandler(TimerAlarm_Tick);

            m_threadListRegisterResponse = new BackgroundWorker ();
            m_threadListRegisterResponse.WorkerSupportsCancellation = true;
            m_threadListRegisterResponse.DoWork += new DoWorkEventHandler(fThreadNotifyResponse_DoWork);
            m_threadListRegisterResponse.RunWorkerCompleted += new RunWorkerCompletedEventHandler(fThreadNotifyResponse_RunWorkerCompleted);

            _dictActionStateResponseHandlers = new Dictionary<StatesMachine, Action<IDataHost, object [], DataTable>> () {
                { StatesMachine.ListDate, responseListDate }
                , { StatesMachine.ListRegister, responseListRegister }
                , { StatesMachine.Detail, responseEventDetail }
                , { StatesMachine.Fixed, responseUpdateFixed }
                //, { StatesMachine.Retry,  }
                , { StatesMachine.Confirm, responseUpdateConfirm }
                //, { StatesMachine.Insert,  }

                // данные будут получены по-этапно
                //#region Опрос данных
                //, { StatesMachine.LastValues, responseLastValues }
                //, { StatesMachine.RDGValues, responseRDGValues }
                //#endregion
            };

            _comparerItemCash = new ComparerItemCash ();
        }

        private void handlerDb_onEventRetryDone (long id, int id_comp, DateTime stampRegistred, TYPE_ALARM type)
        {
            m_dictAlarmObject.RetryDone(new ALARM_KEY (id_comp, stampRegistred, type.Translate()));
        }

        public override void Start()
        {
            //Logging.Logg ().Debug ($@"AdminAlarm::Start () - m_bWorkChecked={m_bWorkChecked}...", Logging.INDEX_MESSAGE.NOT_SET);

            base.Start ();

            m_handlerDb.Start ();

            if ((Mode.HasFlag (AdminAlarm.MODE.REGISTER) == true)
                || (Mode.HasFlag (AdminAlarm.MODE.LAST_VALUES) == true)) {
                actionAdminAlarm (true);
            } else
                ;

            // имитация изменения режима
            OnWorkCheckedChanged (m_bWorkChecked);
        }

        public override void Stop()
        {
            m_handlerDb.Stop ();

            if ((Mode.HasFlag (AdminAlarm.MODE.REGISTER) == true)
                || (Mode.HasFlag (AdminAlarm.MODE.LAST_VALUES) == true)) {
                activateAdminAlarm (false);
                actionAdminAlarm (false);
            } else
                ;

            if (! (m_timerAlarm == null))
            {
                // таймер уже был остановлен в 'activateAdminAlarm'
                m_timerAlarm.Dispose ();
                m_timerAlarm = null;
            }
            else
                ;

            activateViewAlarm(false);
            if (! (m_timerView == null))
            {
                // таймер уже был остановлен в 'activateViewAlarm'
                m_timerView.Dispose();
                m_timerView = null;
            }
            else
                ;

            base.Stop();
        }

        public override bool Activate(bool active)
        {
            bool bRes = base.Activate(active);

            //Logging.Logg ().Debug ($@"AdminAlarm::Activate (active={active}) - Result={bRes}, IsFirstActivated={IsFirstActivated}, m_bWorkChecked={m_bWorkChecked}...", Logging.INDEX_MESSAGE.NOT_SET);

            if (bRes == true) {
                m_handlerDb.Activate (active);

                if (active == true)
                //??? для 'REGISTRED' есть опасность, что не хватит глубины '' для обнаружения очень старых "не зафиксированных/не подтвержденных" событий
                    if (Mode.HasFlag (MODE.LIST_DATE) == true)
                        pushListDate ();
                    else
                        ;
                else
                    ;
            } else
                ;

            return bRes;
        }

        private void actionAdminAlarm(bool act)
        {
            foreach (TecViewAlarm tv in m_listTecView)
                if (act == true)
                        tv.Start();
                else
                    tv.Stop();
        }

        private void activateAdminAlarm(bool bChecked)
        {
            foreach (TecViewAlarm tv in m_listTecView)
                tv.Activate(bChecked);

            // только для периодического обновления параметров ТЭЦ (коэффициент при 'CUR_POWER')
            if (_runable.HasFlag (TYPE_ALARM.CUR_POWER) == true)
                if (bChecked == true)
                    DbTSQLConfigDatabase.DbConfig ().Register ();
                else
                    DbTSQLConfigDatabase.DbConfig ().UnRegister ();
            else
                ;

            m_timerAlarm.Change (bChecked == true ? 0 : System.Threading.Timeout.Infinite
                , System.Threading.Timeout.Infinite);
        }

        private void activateViewAlarm(bool bChecked)
        {
            m_timerView.Change(bChecked == true ? 0 : System.Threading.Timeout.Infinite
                , System.Threading.Timeout.Infinite);
        }

        /// <summary>
        /// Обработчик события изменение признака "Включено/отключено" (выполнять/не_выполнять регистрацию событий)
        /// </summary>
        public void OnWorkCheckedChanged(bool bWorkChecked)
        {
            //if (! (m_bWorkChecked == bChecked)) {
                //??? - Активировать объект чтения/записи/обновления списка событий
                if ((Mode.HasFlag (MODE.REGISTER) == true)
                    || (Mode.HasFlag (AdminAlarm.MODE.LAST_VALUES) == true))
                //??? режим 'SERVICE' - без регистрации событий
                    activateAdminAlarm (bWorkChecked);
                else
                    ;

                activateViewAlarm(bWorkChecked);
            //} else ;
        }

        private void startTimerView(int interval = 6)
        {
            m_timerView.Change(0, System.Threading.Timeout.Infinite);
        }

        private void stopTimerView()
        {
            m_timerView.Change(System.Threading.Timeout.Infinite, System.Threading.Timeout.Infinite);
        }

        /// <summary>
        /// Поставить в очередь обработки событие - запрос перечня событий сигнализаций из БД
        /// </summary>
        private void pushListDate()
        {
            //Logging.Logg ().Debug ($@"AdminAlarm::pushList () - ...", Logging.INDEX_MESSAGE.NOT_SET);

            //Поставить в очередь обработки
            push (new object [] //Перечень событий для обработки
                    { new object [] //1-е событие
                        {
                            StatesMachine.ListDate
                            , m_dtCurrent.Date
                            , m_dtCurrent.HourBegin
                            , m_dtCurrent.HourEnd
                        }
                    });
        }

        /// <summary>
        /// Поставить в очередь обработки событие - запрос перечня событий сигнализаций из БД - текущих (для оповещения)!!!
        /// </summary>
        private void pushListRegister()
        {
            //DateTime dtNotify = HDateTime.ToMoscowTimeZone();
            //Поставить в очередь обработки
            push(new object[] //Перечень событий для обработки
                    { new object [] //1-е событие
                        {
                            StatesMachine.ListRegister
                            , HDateTime.ToMoscowTimeZone() //.Date //dtNotify.Date
                            , -1 * DictAlarmObject.DEPTH_HOUR_OBJECTALRM
                            , 0 //24
                        }
                    });
        }

        private ComparerItemCash _comparerItemCash;

        private class ComparerItemCash : IEqualityComparer<HHandlerQueue.ItemCash>
        {
            public bool Equals (ItemCash x, ItemCash y)
            {
                bool bRes = false
                    , bEqualTypes = false;

                bRes = (x.State == y.State)
                    && (x.Parameters.Count () == y.Parameters.Count ());

                if (bRes == true)
                    for (int i = 0; i < x.Parameters.Count (); i++) {
                        bRes = ((x.Parameters[i].GetType ().Equals (y.Parameters[i]) == true)
                            && (Convert.ChangeType (x.Parameters[i], x.Parameters[i].GetType ()).Equals (Convert.ChangeType (y.Parameters[i], y.Parameters[i].GetType ())) == true));

                        if (bRes == false)
                            break;
                        else
                            ;
                    }
                else
                    ;

                return bRes;
            }

            public int GetHashCode (ItemCash obj)
            {
                int hashCodeTypes = 0;

                obj.Parameters.ToList ().ForEach ((par) => {
                    hashCodeTypes |= par.GetType ().GUID.GetHashCode ();
                });

                return obj.State.GetHashCode() | obj.Parameters.Count().GetHashCode() | hashCodeTypes;
            }
        }

        private void push(object []pars)
        {
            //fDebugQueue (pars);

            //Поставить в очередь обработки
            // null - получатель/отправитель
            Push(null, new object[] //???
                { pars }
                , _comparerItemCash);
        }

        /// <summary>
        /// Метод обратного вызова для таймера обновления значений в таблице
        /// </summary>
        /// <param name="obj">Объект, инициировавший событие</param>
        private void fTimerView_Tick(object obj)
        {
            // поставить в очередь событие получения списка событий сигнализаций
            //  за указанную дату/часы только, если дата текущая
            if ((isToday == true) // в режимах: 'Admin', 'View' - события за прошедшие и будущие сутки не могут изменяться, т.к. их регистрация происходит в режиме реального времени
                && (Mode.HasFlag (MODE.LIST_DATE) == true)) {
                m_dtCurrent = new DatetimeCurrentEventArgs (m_dtCurrent.Date.AddDays (1), m_dtCurrent.HourBegin, m_dtCurrent.HourEnd);
                pushListDate ();
            } else
                ;

            // поставить в очередь событие получения списка текущих событий сигнализаций
            if (Mode.HasFlag (MODE.REGISTER) == true)
                pushListRegister ();
            else
                ;

            // для очередного запуска
            m_timerView.Change(PanelStatistic.POOL_TIME * 1000, System.Threading.Timeout.Infinite);
        }

        /// <summary>
        /// Обработчик события - изменение даты, номера часа начала и окончания
        /// </summary>
        /// <param name="ev">Аргумент события</param>
        public void OnEventDatetimeChanged(DatetimeCurrentEventArgs ev)
        {
            m_dtCurrent = ev;

            pushListDate ();
            ////Проверить равенство установленной даты и текущей
            //// в случае успеха - отодвинуть вызов потоковой функции таймера
            //if (isToday == true)
            //    m_timerView.Change(PanelStatistic.POOL_TIME, System.Threading.Timeout.Infinite);
            //else
            //    ;
        }

        /// <summary>
        /// Признак постановки в очередь обработки событий - запроса на получение списка собтий сигнализаций
        ///  по заданной пользователем дате
        /// </summary>
        private bool isToday { get { return m_dtCurrent.Date.Equals(HDateTime.ToMoscowTimeZone ().Date); } }

        /// <summary>
        /// Потоковая функция обработки результата запроса списка событий сигнализаций
        /// </summary>
        /// <param name="obj">Объект, инициировавший событие (??? поток)</param>
        /// <param name="ev">Аргумент события начала выполнения потока</param>
        private void fThreadNotifyResponse_DoWork (object obj, DoWorkEventArgs ev)
        {
            DataTable tableRes = ev.Argument as DataTable;
            //DataRow []rowsUnFixed = tableRes.Select (@"[DATETIME_FIXED] IS NULL", @"[DATETIME_REGISTRED]");
            foreach (DataRow r in tableRes.Rows)
                EventReg(new AlarmDbEventArgs(r));

            ev.Result = @"Ok";

            //??? каждые 6 сек фиксировать факт проверки
            // , требуется дополнительная настройка 'D001..D006'
            // , тем более 'Debug' а не 'Action'
            //Logging.Logg ().Debug (string.Format($"Поток: проверка наличия текущих событий за {HDateTime.ToMoscowTimeZone ().ToShortDateString()}; кол-во_событий={tableRes.Rows.Count}...")
            //    , Logging.INDEX_MESSAGE.NOT_SET);
        }

        /// <summary>
        /// Обработчик события - завершения выполнения потоковой функции по обработке
        ///  результатов запроса списка событий сигнализаций
        /// </summary>
        /// <param name="obj">Объект, инициировавший событие (??? поток)</param>
        /// <param name="ev">Аргумент события окончанмя выполнения потоковой функции</param>
        private void fThreadNotifyResponse_RunWorkerCompleted(object obj, RunWorkerCompletedEventArgs ev)
        {
            if (object.Equals (ev.Error, null) == false)
            {
                Logging.Logg().Exception(ev.Error, @"ViewAlarm::fThreadListEventsResponse_DoWork () - ...", Logging.INDEX_MESSAGE.NOT_SET);
            }
            else
                //Console.WriteLine(@"ViewAlarm::fThreadNotifyResponse_RunWorkerCompleted () - " + ev.Result + @"...")
                ;

            //m_bAlarmDbEventUpdated = true;
            m_mEvtAlarmDbEventUpdated.Set();
        }

        /// <summary>
        /// Функция обработки результатов запроса по указанной дате/часам
        /// </summary>
        /// <param name="dataHost">Объект для обратной связи (инициировавший обработку события и ожидающий ответа)</param>
        /// <param name="parameters">Массив - аргументы очередного события в очереди обработки событий</param>
        /// <param name="tableRes">Таблица - результат запроса</param>
        private void responseListDate(IDataHost dataHost, object [] parameters, DataTable tableRes)
        {
            List<ViewAlarmJournal> listRes;

            actionReport?.Invoke (string.Format ($"Событий за {((DateTime)parameters [0]).ToShortDateString ()} ({((int)parameters [1])}-{((int)parameters [2])} ч): {tableRes.Rows.Count}"));
            readyData?.Invoke ((DateTime)parameters [0], true);

            listRes = new List<ViewAlarmJournal>(tableRes.Rows.Count);

            try
            {
                foreach (DataRow r in tableRes.Rows)
                {
                    listRes.Add(new ViewAlarmJournal()
                    {
                        m_id = (long)r[@"ID"]
                        , m_id_owner = getIdOwner((int)r[@"ID_COMPONENT"])
                        , m_id_component = (int)r[@"ID_COMPONENT"]
                        , m_str_name_shr_component = getNameComponent((int)r[@"ID_COMPONENT"])
                        , m_type = (TYPE_ALARM)r[@"TYPE"]
                        , m_str_name_shr_type = (TYPE_ALARM)r[@"TYPE"] == TYPE_ALARM.CUR_POWER ? @"Тек.мощн."
                            : (TYPE_ALARM)r[@"TYPE"] == TYPE_ALARM.TG_TURNONOFF ? @"ТГвкл/откл"
                                : (TYPE_ALARM)r[@"TYPE"] == TYPE_ALARM.APOWER ? @"Генер."
                                    : (TYPE_ALARM)r[@"TYPE"] == TYPE_ALARM.FREQ ? @"Част."
                                        : string.Empty
                        , m_value = (float)r[@"VALUE"]
                        , m_id_user_registred = (int)r[@"ID_USER_REGISTRED"]
                        , m_dt_registred = (DateTime)r[@"DATETIME_REGISTRED"]
                        , m_id_user_fixed = (!(r[@"ID_USER_FIXED"] is DBNull)) ? (int)r[@"ID_USER_FIXED"] : -1
                        , m_dt_fixed = (!(r[@"DATETIME_FIXED"] is DBNull)) ? (DateTime?)r[@"DATETIME_FIXED"] : null
                        , m_id_user_confirmed = (!(r[@"ID_USER_CONFIRM"] is DBNull)) ? (int)r[@"ID_USER_CONFIRM"] : -1
                        , m_dt_confirmed = (!(r[@"DATETIME_CONFIRM"] is DBNull)) ? (DateTime?)r[@"DATETIME_CONFIRM"] : null
                        , m_situation = (int)r[@"SITUATION"]
                    });
                }
            }
            catch (Exception e)
            {
                Logging.Logg().Exception(e, @"AdminAlarm::GetListEventsResponse () - ...", Logging.INDEX_MESSAGE.NOT_SET);
            }

            //Logging.Logg ().Debug ($@"AdminAlarm::GetListEventsResponse () - Actived={Actived}...", Logging.INDEX_MESSAGE.NOT_SET);

            if (Actived == true)
                EventListEventDate?.Invoke(listRes);
            else ;
        }

        private const int TIMEOUT_DBEVENT_UPDATE = 666;

        /// <summary>
        /// Функция обработки результатов запроса текущих!!! событий сигнализаций
        /// </summary>
        /// <param name="dataHost">Объект для обратной связи (инициировавший обработку события и ожидающий ответа)</param>
        /// <param name="parameters">Массив - аргументы очередного события в очереди обработки событий</param>
        /// <param name="tableRes">Таблица - результат запроса</param>
        private void responseListRegister(IDataHost dataHost, object[]parameters, DataTable tableRes)
        {
            if (m_threadListRegisterResponse.IsBusy == true)
                m_threadListRegisterResponse.CancelAsync();
            else
                ;

            // ожидать завершения потока обработки запроса текущих событий
            //if (m_bAlarmDbEventUpdated == false)
            if (m_mEvtAlarmDbEventUpdated.WaitOne(TIMEOUT_DBEVENT_UPDATE) == true)
                try {
                    // установить признак выполнения обработки запроса текущих событий
                    m_mEvtAlarmDbEventUpdated.Reset ();
                    m_threadListRegisterResponse.RunWorkerAsync(tableRes);
                } catch (Exception e) {
                    Logging.Logg().Exception(e, string.Format(@"AdminAlarm::GetNotifyResponse () - обработка не выполнена ..."), Logging.INDEX_MESSAGE.NOT_SET);
                }
            else
                Logging.Logg().Error(string.Format(@"AdminAlarm::GetNotifyResponse () - обработка не выполнена, время ожидания истекло ..."), Logging.INDEX_MESSAGE.NOT_SET);
        }

        /// <summary>
        /// Обработать получение детализации события сигнализации
        /// </summary>
        /// <param name="dataHost">Объект для обратной связи (инициировавший обработку события и ожидающий ответа)</param>
        /// <param name="parameters">Массив - аргументы очередного события в очереди обработки событий</param>
        /// <param name="tableRes">Таблица - результат запроса</param>
        private void responseEventDetail(IDataHost dataHost, object []parameters, DataTable tableRes)
        {
            List<ViewAlarmDetail> listRes = new List<ViewAlarmDetail> ();

            foreach (DataRow r in tableRes.Rows)
            {
                listRes.Add(new ViewAlarmDetail()
                {
                    m_id = (long)r[@"ID"]
                    , m_id_owner = getIdOwner((int)r[@"ID_COMPONENT"])
                    , m_id_event = (long)r[@"ID_EVENT"]
                    , m_id_component = (int)r[@"ID_COMPONENT"]
                    , m_str_name_shr_component = getNameComponent((int)r[@"ID_COMPONENT"])
                    , m_value = (float)r[@"VALUE"]
                    , m_last_changed_at = (DateTime?)r[@"last_changed_at"]
                });
            }
            //Вариант №1
            EventDetailEvents(listRes);
            ////Вариант №2 (через посредника 'PanelAlarm::OnEvtDataRecievedHost')
            //itemQueue.m_dataHostRecieved.OnEvtDataRecievedHost(new EventArgsDataHost(-1, new object[] { StatesMachine.Detail, listRes }));
        }

        /// <summary>
        /// Обработать результат запроса по обновлению даты/времени фиксации события
        /// </summary>
        /// <param name="dataHost">Объект для обратной связи (инициировавший обработку события и ожидающий ответа)</param>
        /// <param name="parameters">Массив - аргументы очередного события в очереди обработки событий</param>
        /// <param name="tableRes">Таблица - результат запроса</param>
        private void responseUpdateFixed(IDataHost dataHost, object[]parameters, DataTable tableRes)
        {
            DataRow r = tableRes.Rows [0];
            m_dictAlarmObject.Fixed ((int)r[@"ID_COMPONENT"], (DateTime)r[@"DATETIME_REGISTRED"], (DateTime)r[@"DATETIME_FIXED"]);
            //Проверить признак автоматической фиксации
            dataHost?.OnEvtDataRecievedHost(new EventArgsDataHost(-1, -1, new object[] { StatesMachine.Fixed, (long)r[@"ID"], (DateTime)r[@"DATETIME_FIXED"] }));
        }

        /// <summary>
        /// Обработать результат запроса по обновлению даты/времени подтверждения события
        /// </summary>
        /// <param name="dataHost">Объект для обратной связи (инициировавший обработку события и ожидающий ответа)</param>
        /// <param name="parameters">Массив - аргументы очередного события в очереди обработки событий</param>
        /// <param name="tableRes">Таблица - результат запроса</param>
        private void responseUpdateConfirm(IDataHost dataHost, object[]parameters, DataTable tableRes)
        {
            DataRow r = tableRes.Rows[0];
            m_dictAlarmObject.Confirmed((int)r[@"ID_COMPONENT"], (DateTime)r[@"DATETIME_REGISTRED"], (DateTime)r[@"DATETIME_CONFIRM"]);
            //Проверить признак автоматического подтверждения
            dataHost?.OnEvtDataRecievedHost(new EventArgsDataHost(-1, -1, new object[] { StatesMachine.Confirm, (long)r[@"ID"], (DateTime)r[@"DATETIME_CONFIRM"] }));
        }

        //#region Опрос данных
        //private void responseLastValues (IDataHost dataHost, object[] parameters, DataTable tableRes)
        //{
        //}

        //private void responseRDGValues (IDataHost dataHost, object[] parameters, DataTable tableRes)
        //{
        //}
        //#endregion

        private string getEventGUIMessage(AlarmNotifyEventArgs ev)
        {
            string strRes = getNameComponent (ev.m_id_comp);

            if (strRes.Equals (string.Empty) == false)
            {
                strRes += Environment.NewLine;
                strRes += HDateTime.ToMoscowTimeZone(ev.m_dtRegistred.GetValueOrDefault()).ToString();
                strRes += Environment.NewLine;
                strRes += ev.m_message_shr;
            }
            else
                ;

            return strRes;
        }

        private int getIdOwner(int id_comp)
        {
            int iRes = -1;
            FormChangeMode.MODE_TECCOMPONENT mode = TECComponent.GetMode (id_comp);
            bool bContinue = true;

            foreach (TecView tv in m_listTecView)
            {
                foreach (TECComponent tc in tv.m_tec.ListTECComponents)
                {
                    if (mode == FormChangeMode.MODE_TECCOMPONENT.GTP)
                        if (tc.m_id == id_comp)
                        {
                            //iRes оставить безизменений
                            bContinue = false;
                            break;
                        }
                        else
                            ;
                    else
                        if (mode == FormChangeMode.MODE_TECCOMPONENT.TG)
                            if (tc.IsGTP == true)
                                foreach (TECComponentBase lpd in tc.ListLowPointDev)
                                    if (lpd.m_id == id_comp)
                                    {
                                        iRes = tc.m_id;
                                        bContinue = false;
                                        break;
                                    }
                                    else
                                        ;
                            else
                                ;
                        else
                            ;

                    if (bContinue == false)
                        break;
                    else
                        ;
                }

                if (bContinue == false)
                    break;
                else
                    ;
            }

            return iRes;
        }

        private string getNameComponent(int id_comp)
        {
            string strRes = string.Empty;
            bool bContinue = true;

            foreach (TecView tv in m_listTecView)
            {
                foreach (TECComponent tc in tv.m_tec.ListTECComponents)
                    if (tc.m_id == id_comp)
                    {
                        strRes += tv.m_tec.name_shr;
                        strRes += @", ";
                        strRes += tc.name_shr;
                        
                        bContinue = false;
                        break;
                    }
                    else
                        ;

                if (bContinue == false)
                    break;
                else
                    ;
            }

            return strRes;
        }

        /// <summary>
        /// Обработчик события регистрации события из БД
        /// </summary>
        /// <param name="ev">Аргумент события - описание события сигнализации</param>
        private void onEventReg(AlarmDbEventArgs ev)
        {
            INDEX_ACTION iAction = m_dictAlarmObject.Registred (ev, Mode);
            if (iAction == INDEX_ACTION.ERROR)
                throw new Exception(@"ViewAlarm::onEventReg () - ...");
            else
                switch (iAction)
                {
                    // оповещение только для 'ADMIN'
                    case INDEX_ACTION.NEW:
                    case INDEX_ACTION.RETRY:
                        ev.m_messageGUI = getEventGUIMessage (ev);
                        if (iAction == INDEX_ACTION.NEW)
                            EventAdd(ev);
                        else
                            if (iAction == INDEX_ACTION.RETRY)
                                EventRetry(ev);
                            else
                                ;
                        break;
                    case INDEX_ACTION.AUTO_FIXING: // автофиксация/подтверждение только для 'SERVICE'
                        Push(null, new object[] {
                            new object [] {
                                new object [] {
                                    AdminAlarm.StatesMachine.Fixed
                                    , ev as AlarmNotifyEventArgs
                                }
                            }
                        }
                        , _comparerItemCash);
                        break;
                    case INDEX_ACTION.AUTO_CONFIRMING: // автофиксация/подтверждение только для 'SERVICE'
                        Push(null, new object[] {
                            new object[] {
                                new object [] {
                                    AdminAlarm.StatesMachine.Confirm
                                    //TODO: не хватает 'm_oicdac_paramater'
                                    , new object [] { ev.m_id, ev.m_id_comp, ev.m_situation }
                                }
                            }
                        }
                        , _comparerItemCash);
                        break;
                    //case INDEX_ACTION.CONFIRMED_TG:
                    //    tgConfirm(ev.m_id_comp, (TG.INDEX_TURNOnOff)ev.m_situation);
                    //    break;
                    default:
                        break;
                }
        }

        ///// <summary>
        ///// Обработчик события - подтверждение события сигнализации от панели (пользователя)
        ///// </summary>
        ///// <param name="id_comp">Часть составного ключа: идентификатор ГТП</param>
        ///// <param name="id_tg">Часть составного ключа: идентификатор ТГ</param>
        //public void OnEventConfirm (AlarmNotifyEventArgs ev)
        //{
        //    Logging.Logg().Debug(@"ViewAlarm::OnEventConfirm (id=" + ev.m_id_comp.ToString() + @") - ...", Logging.INDEX_MESSAGE.NOT_SET);

        //    if (!(m_dictAlarmObject.Confirmed(ev.m_id_comp, ev.m_dtRegistred.GetValueOrDefault()) < 0))
        //    {
        //        push(new object[] //Перечень событий
        //            {
        //                new object [] //1-е событие
        //                {
        //                    StatesMachine.Confirm
        //                    , ev.m_id_comp
        //                    , ev.m_dtRegistred
        //                }
        //            });

        //        if (StatisticCommon.TECComponent.Mode(ev.m_id_comp) == FormChangeMode.MODE_TECCOMPONENT.TG)
        //            tgConfirm(ev.m_id_comp);
        //        else
        //            ;
        //    }
        //    else
        //        Logging.Logg().Error(@"ViewAlarm::OnEventConfirm (id=" + ev.m_id_comp.ToString() + @") - НЕ НАЙДЕН!", Logging.INDEX_MESSAGE.NOT_SET);
        //}
        ///// <summary>
        ///// Возвратить признак "подтверждено" для события сигнализации
        ///// </summary>
        ///// <param name="id_comp">Часть составного ключа: идентификатор ГТП</param>
        ///// <param name="id_tg">Часть составного ключа: идентификатор ТГ</param>
        ///// <returns>Результат: признак установлен/не_установлен)</returns>
        //public bool IsConfirmed(int id_comp, DateTime dtReg)
        //{
        //    return m_dictAlarmObject.IsConfirmed(id_comp, dtReg);
        //}
        ///// <summary>
        ///// Получить дату/время регистрации события сигнализации для ТГ
        ///// </summary>
        ///// <param name="id_comp">Составная часть ключа: идентификатор ГТП</param>
        ///// <param name="id_tg">Составная часть ключа: идентификатор ГТП</param>
        ///// <returns></returns>
        //public DateTime TGAlarmDatetimeReg(int id_comp, DateTime dtReg)
        //{
        //    return m_dictAlarmObject.TGAlarmDatetimeReg(id_comp, dtReg);
        //}

            /// <summary>
        /// Получить результат запроса для события
        /// </summary>
        /// <param name="state">Идентификатор события</param>
        /// <param name="error">Признак получения результата запроса</param>
        /// <param name="table">Результат запроса - таблица ('DataTable')</param>
        /// <returns>Признак выполнения операции</returns>
        protected override int StateCheckResponse(int state, out bool error, out object table)
        {
            int iRes = 0;
            HandlerDb.INDEX_SYNC_STATECHECKRESPONSE indxSync = HandlerDb.INDEX_SYNC_STATECHECKRESPONSE.UNKNOWN;

            error = false;
            table = null;

            switch ((StatesMachine)state) {

                case StatesMachine.ListDate:
                case StatesMachine.Detail:
                case StatesMachine.ListRegister:
                case StatesMachine.Insert:
                case StatesMachine.Retry:
                case StatesMachine.Fixed:
                case StatesMachine.Confirm:

                #region Опрос данных
                case StatesMachine.LastValues:
                case StatesMachine.CurPowerValues:
                #endregion

                    indxSync = (HandlerDb.INDEX_SYNC_STATECHECKRESPONSE)WaitHandle.WaitAny(m_handlerDb.m_arSyncStateCheckResponse);
                    switch (indxSync)
                    {
                        case HandlerDb.INDEX_SYNC_STATECHECKRESPONSE.RESPONSE:
                            iRes = m_handlerDb.Response (out error, out table);
                            break;
                        case HandlerDb.INDEX_SYNC_STATECHECKRESPONSE.ERROR:
                            iRes = -1;
                            break;
                        case HandlerDb.INDEX_SYNC_STATECHECKRESPONSE.WARNING:
                            iRes = 1;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    iRes = -1;
                    break;
            }

            error = !(iRes == 0);

            return iRes;
        }

        /// <summary>
        /// Отправить запрос для события
        /// </summary>
        /// <param name="state">Идентификатор состояния</param>
        /// <returns>Результат отправления запроса</returns>
        protected override int StateRequest(int state)
        {
            int iRes = 0;
            CashQueue cashQueue = Peek;

            //Logging.Logg ().Debug ($@"AdminAlarm::StateRequest (state={(StatesMachine)state}) - ...", Logging.INDEX_MESSAGE.NOT_SET);

            switch ((StatesMachine)state)
            {
                case StatesMachine.ListDate:
                case StatesMachine.ListRegister:
                    m_handlerDb.Refresh ((DateTime)cashQueue.Pars[0], (int)cashQueue.Pars[1], (int)cashQueue.Pars[2]);
                    break;
                case StatesMachine.Detail:
                    m_handlerDb.Detail((long)cashQueue.Pars[0]);
                    break;
                case StatesMachine.Insert:
                    m_handlerDb.Insert(cashQueue.Pars[0] as TecViewAlarm.AlarmTecViewEventArgs);
                    break;
                case StatesMachine.Retry:
                    m_handlerDb.Retry(cashQueue.Pars[0] as TecViewAlarm.AlarmTecViewEventArgs);
                    break;
                case StatesMachine.Fixed:
                    AlarmNotifyEventArgs ev = cashQueue.Pars[0] as AlarmNotifyEventArgs;
                    if ((TECComponent.GetMode (ev.m_id_comp) == FormChangeMode.MODE_TECCOMPONENT.TG)
                        && (ev.m_oicdac_parameter == StatisticCommon.OICDAC.DbInterface.OIKParameter.UNKNOWN))
                        tgConfirm (ev.m_id_comp, (TG.INDEX_TURNOnOff)ev.m_situation);
                    else
                        ;
                    m_handlerDb.Fixed(ev);
                    break;
                case StatesMachine.Confirm:
                    object[] pars = cashQueue.Pars[0] as object[];
                    //long id_rec = (long)(pars)[0];
                    //int id_comp = (int)(pars)[1];
                    //if (TECComponent.Mode(id_comp) == FormChangeMode.MODE_TECCOMPONENT.TG)
                    //    tgConfirm(id_comp, (TG.INDEX_TURNOnOff)pars[2]);
                    //else
                    //    ;
                    //m_handlerDb.Confirm(id_rec);
                    m_handlerDb.Confirm((long)(pars)[0]);
                    break;

                #region Опрос значений
                case StatesMachine.LastValues:
                    m_handlerDb.LastValues (GetAlarmRegistredRequired (TYPE_ALARM.FREQ));
                    break;
                case StatesMachine.CurPowerValues:
                    m_handlerDb.CurPowerValues (cashQueue.Pars[0] as CurPowerEventArgs);
                    break;
                #endregion

                default:
                    break;
            }

            //Logging.Logg().Debug(@"ViewAlarm::StateRequest () - state=" + ((StatesMachine)state).ToString() + @", result=" + bRes.ToString() + @" - вЫход...");

            return iRes;
        }

        /// <summary>
        /// Обработать результат запроса для состояния
        /// </summary>
        /// <param name="state">Идентификатор состояния</param>
        /// <param name="obj">Результат выполнения запроса</param>
        /// <returns>Признак обработки результата запроса</returns>
        protected override int StateResponse(int state, object obj)
        {
            int iRes = 0;
            CashQueue cashQueue = Peek;
            DataTable tableRes = obj as DataTable;

            switch ((StatesMachine)state)
            {
                case StatesMachine.ListDate:
                case StatesMachine.ListRegister:
                case StatesMachine.Detail:
                case StatesMachine.Fixed:
                case StatesMachine.Confirm:

                #region Опрос данных
                case StatesMachine.LastValues:
                case StatesMachine.CurPowerValues:
                #endregion

                    if (_dictActionStateResponseHandlers.ContainsKey ((StatesMachine)state) == true)
                        _dictActionStateResponseHandlers [(StatesMachine)state]?.Invoke (cashQueue.m_dataHostRecieved, cashQueue.Pars, tableRes);
                    else
                        ;
                    break;
                case StatesMachine.Retry:
                // происходит только в режиме 'SERVICE'
                    break;
                case StatesMachine.Insert:
                //Результата нет (рез-т вставленные/обновленные записи)
                    break;
                default:
                    break;
            }

            //Вариант №1
            //??? прямой вызов метода-обработчика..., ??? использование объекта, полученного в качестве параметра... - очень некрасиво, и, возможно - неправильно
            // для отправителя/получателя результата панели
            //itemQueue.m_dataHostRecieved.OnEvtDataRecievedHost(new EventArgsDataHost(-1, new object[] { (StatesMachine)state, tableRes }));

            //Logging.Logg().Debug(@"ViewAlarm::StateResponse () - state=" + ((StatesMachine)state).ToString() + @", result=" + bRes.ToString() + @" - вЫход...");

            return iRes;
        }

        protected override HHandler.INDEX_WAITHANDLE_REASON StateErrors(int state, int req, int res)
        {
            Logging.Logg().Error(@"ViewAlarm::StateErrors () - state=" + ((StatesMachine)state).ToString() + @", req=" + req.ToString() + @", res=" + res.ToString(), Logging.INDEX_MESSAGE.NOT_SET);

            return INDEX_WAITHANDLE_REASON.SUCCESS;
        }

        protected override void StateWarnings(int state, int req, int res)
        {
            Logging.Logg().Warning(@"ViewAlarm::StateWarnings () - state=" + ((StatesMachine)state).ToString() + @", req=" + req.ToString() + @", res=" + res.ToString(), Logging.INDEX_MESSAGE.NOT_SET);
        }

        /// <summary>
        /// Обработчик запросов на получение данных от 'PanelAlarm'
        ///  в котором реализован интерфейс 'IDataHost'
        /// </summary>
        /// <param name="obj">Аргумент, детализирующий выполнение запрос</param>
        public void OnEvtDataAskedHost (object obj)
        {
            Push ((obj as EventArgsDataHost).reciever, new object [] { (obj as EventArgsDataHost).par }, _comparerItemCash);
        }
    }

    internal static class HandlerDbStatesMachineExtensions
    {
        public static TYPE_ALARM Translate (this AdminAlarm.HandlerDb.StatesMachine target)
        {
            return target == AdminAlarm.HandlerDb.StatesMachine.LastValues_TM_Gen ? TYPE_ALARM.APOWER
                : target == AdminAlarm.HandlerDb.StatesMachine.LastValues_TM_Freq ? TYPE_ALARM.FREQ
                    : TYPE_ALARM.UNKNOWN;
        }
    }
}
